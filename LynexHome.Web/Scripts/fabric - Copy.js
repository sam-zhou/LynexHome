var fabric = fabric || { version: "1.7.9" }; "undefined" != typeof exports && (exports.fabric = fabric), "undefined" != typeof document && "undefined" != typeof window ? (fabric.document = document, fabric.window = window, window.fabric = fabric) : (fabric.document = require("jsdom").jsdom(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E")), fabric.window = fabric.document.createWindow ? fabric.document.createWindow() : fabric.document.parentWindow), fabric.isTouchSupported = "ontouchstart" in fabric.document.documentElement, fabric.isLikelyNode = "undefined" != typeof Buffer && "undefined" == typeof window, fabric.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id"], fabric.DPI = 96, fabric.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)", fabric.fontPaths = {}, fabric.iMatrix = [1, 0, 0, 1, 0, 0], fabric.charWidthsCache = {}, fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1; if ("undefined" == typeof eventjs) var eventjs = {}; if (function (e) { "use strict"; e.modifyEventListener = !1, e.modifySelectors = !1, e.configure = function (t) { isFinite(t.modifyEventListener) && (e.modifyEventListener = t.modifyEventListener), isFinite(t.modifySelectors) && (e.modifySelectors = t.modifySelectors), l === !1 && e.modifyEventListener && p(), g === !1 && e.modifySelectors && m() }, e.add = function (e, t, r, o) { return n(e, t, r, o, "add") }, e.remove = function (e, t, r, o) { return n(e, t, r, o, "remove") }, e.returnFalse = function () { return !1 }, e.stop = function (e) { e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0, e.cancelBubbleCount = 0) }, e.prevent = function (e) { e && (e.preventDefault ? e.preventDefault() : e.preventManipulation ? e.preventManipulation() : e.returnValue = !1) }, e.cancel = function (t) { e.stop(t), e.prevent(t) }, e.blur = function () { var e = document.activeElement; if (e) { var t = document.activeElement.nodeName; ("INPUT" === t || "TEXTAREA" === t || "true" === e.contentEditable) && e.blur && e.blur() } }, e.getEventSupport = function (e, t) { if ("string" == typeof e && (t = e, e = window), t = "on" + t, t in e) return !0; if (e.setAttribute || (e = document.createElement("div")), e.setAttribute && e.removeAttribute) { e.setAttribute(t, ""); var n = "function" == typeof e[t]; return "undefined" != typeof e[t] && (e[t] = null), e.removeAttribute(t), n } }; var t = function (e) { if (!e || "object" != typeof e) return e; var n = new e.constructor; for (var r in e) n[r] = e[r] && "object" == typeof e[r] ? t(e[r]) : e[r]; return n }, n = function (i, s, c, l, p, g) { if (l = l || {}, "[object Object]" === String(i)) { var m = i; if (i = m.target, delete m.target, !m.type || !m.listener) { for (var y in m) { var h = m[y]; "function" != typeof h && (l[y] = h) } var j = {}; for (var b in m) { var y = b.split(","), w = m[b], x = {}; for (var P in l) x[P] = l[P]; if ("function" == typeof w) var c = w; else { if ("function" != typeof w.listener) continue; var c = w.listener; for (var P in w) "function" != typeof w[P] && (x[P] = w[P]) } for (var E = 0; E < y.length; E++) j[b] = eventjs.add(i, y[E], c, x, p) } return j } s = m.type, delete m.type, c = m.listener, delete m.listener; for (var b in m) l[b] = m[b] } if (i && s && c) { if ("string" == typeof i && "ready" === s) { if (!window.eventjs_stallOnReady) { var M = (new Date).getTime(), T = l.timeout, _ = l.interval || 1e3 / 60, G = window.setInterval(function () { (new Date).getTime() - M > T && window.clearInterval(G), document.querySelector(i) && (window.clearInterval(G), setTimeout(c, 1)) }, _); return } s = "load", i = window } if ("string" == typeof i) { if (i = document.querySelectorAll(i), 0 === i.length) return o("Missing target on listener!", arguments); 1 === i.length && (i = i[0]) } var L, D = {}; if (i.length > 0 && i !== window) { for (var O = 0, k = i.length; k > O; O++) L = n(i[O], s, c, t(l), p), L && (D[O] = L); return r(D) } if ("string" == typeof s && (s = s.toLowerCase(), -1 !== s.indexOf(" ") ? s = s.split(" ") : -1 !== s.indexOf(",") && (s = s.split(","))), "string" != typeof s) { if ("number" == typeof s.length) for (var C = 0, F = s.length; F > C; C++) L = n(i, s[C], c, t(l), p), L && (D[s[C]] = L); else for (var b in s) L = "function" == typeof s[b] ? n(i, b, s[b], t(l), p) : n(i, b, s[b].listener, t(s[b]), p), L && (D[b] = L); return r(D) } if (0 === s.indexOf("on") && (s = s.substr(2)), "object" != typeof i) return o("Target is not defined!", arguments); if ("function" != typeof c) return o("Listener is not a function!", arguments); var S = l.useCapture || !1, X = f(i) + "." + f(c) + "." + (S ? 1 : 0); if (e.Gesture && e.Gesture._gestureHandlers[s]) { if (X = s + X, "remove" === p) { if (!u[X]) return; u[X].remove(), delete u[X] } else if ("add" === p) { if (u[X]) return u[X].add(), u[X]; if (l.useCall && !e.modifyEventListener) { var Y = c; c = function (e, t) { for (var n in t) e[n] = t[n]; return Y.call(i, e) } } l.gesture = s, l.target = i, l.listener = c, l.fromOverwrite = g, u[X] = e.proxy[s](l) } return u[X] } for (var H, U = a(s), E = 0; E < U.length; E++) if (s = U[E], H = s + "." + X, "remove" === p) { if (!u[H]) continue; i[d](s, c, S), delete u[H] } else if ("add" === p) { if (u[H]) return u[H]; i[v](s, c, S), u[H] = { id: H, type: s, target: i, listener: c, remove: function () { for (var t = 0; t < U.length; t++) e.remove(i, U[t], c, l) } } } return u[H] } }, r = function (e) { return { remove: function () { for (var t in e) e[t].remove() }, add: function () { for (var t in e) e[t].add() } } }, o = function (e, t) { "undefined" != typeof console && "undefined" != typeof console.error && console.error(e, t) }, i = { msPointer: ["MSPointerDown", "MSPointerMove", "MSPointerUp"], touch: ["touchstart", "touchmove", "touchend"], mouse: ["mousedown", "mousemove", "mouseup"] }, s = { MSPointerDown: 0, MSPointerMove: 1, MSPointerUp: 2, touchstart: 0, touchmove: 1, touchend: 2, mousedown: 0, mousemove: 1, mouseup: 2 }, a = (function () { e.supports = {}, window.navigator.msPointerEnabled && (e.supports.msPointer = !0), e.getEventSupport("touchstart") && (e.supports.touch = !0), e.getEventSupport("mousedown") && (e.supports.mouse = !0) }(), function () { return function (t) { var n = document.addEventListener ? "" : "on", r = s[t]; if (isFinite(r)) { var o = []; for (var a in e.supports) o.push(n + i[a][r]); return o } return [n + t] } }()), u = {}, c = 0, f = function (e) { return e === window ? "#window" : e === document ? "#document" : (e.uniqueID || (e.uniqueID = "e" + c++), e.uniqueID) }, v = document.addEventListener ? "addEventListener" : "attachEvent", d = document.removeEventListener ? "removeEventListener" : "detachEvent"; e.createPointerEvent = function (t, n, r) { var o = n.gesture, i = n.target, s = t.changedTouches || e.proxy.getCoords(t); if (s.length) { var a = s[0]; n.pointers = r ? [] : s, n.pageX = a.pageX, n.pageY = a.pageY, n.x = n.pageX, n.y = n.pageY } var u = document.createEvent("Event"); u.initEvent(o, !0, !0), u.originalEvent = t; for (var c in n) "target" !== c && (u[c] = n[c]); var f = u.type; e.Gesture && e.Gesture._gestureHandlers[f] && n.oldListener.call(i, u, n, !1) }; var l = !1, p = function () { if (window.HTMLElement) { var t = function (t) { var r = function (r) { var o = r + "EventListener", i = t[o]; t[o] = function (t, o, s) { if (e.Gesture && e.Gesture._gestureHandlers[t]) { var u = s; "object" == typeof s ? u.useCall = !0 : u = { useCall: !0, useCapture: s }, n(this, t, o, u, r, !0) } else for (var c = a(t), f = 0; f < c.length; f++) i.call(this, c[f], o, s) } }; r("add"), r("remove") }; navigator.userAgent.match(/Firefox/) ? (t(HTMLDivElement.prototype), t(HTMLCanvasElement.prototype)) : t(HTMLElement.prototype), t(document), t(window) } }, g = !1, m = function () { var e = NodeList.prototype; e.removeEventListener = function (e, t, n) { for (var r = 0, o = this.length; o > r; r++) this[r].removeEventListener(e, t, n) }, e.addEventListener = function (e, t, n) { for (var r = 0, o = this.length; o > r; r++) this[r].addEventListener(e, t, n) } }; return e }(eventjs), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; e.pointerSetup = function (e, t) { e.target = e.target || window, e.doc = e.target.ownerDocument || e.target, e.minFingers = e.minFingers || e.fingers || 1, e.maxFingers = e.maxFingers || e.fingers || 1 / 0, e.position = e.position || "relative", delete e.fingers, t = t || {}, t.enabled = !0, t.gesture = e.gesture, t.target = e.target, t.env = e.env, eventjs.modifyEventListener && e.fromOverwrite && (e.oldListener = e.listener, e.listener = eventjs.createPointerEvent); var n = 0, r = 0 === t.gesture.indexOf("pointer") && eventjs.modifyEventListener ? "pointer" : "mouse"; return e.oldListener && (t.oldListener = e.oldListener), t.listener = e.listener, t.proxy = function (n) { t.defaultListener = e.listener, e.listener = n, n(e.event, t) }, t.add = function () { t.enabled !== !0 && (e.onPointerDown && eventjs.add(e.target, r + "down", e.onPointerDown), e.onPointerMove && eventjs.add(e.doc, r + "move", e.onPointerMove), e.onPointerUp && eventjs.add(e.doc, r + "up", e.onPointerUp), t.enabled = !0) }, t.remove = function () { t.enabled !== !1 && (e.onPointerDown && eventjs.remove(e.target, r + "down", e.onPointerDown), e.onPointerMove && eventjs.remove(e.doc, r + "move", e.onPointerMove), e.onPointerUp && eventjs.remove(e.doc, r + "up", e.onPointerUp), t.reset(), t.enabled = !1) }, t.pause = function (t) { !e.onPointerMove || t && !t.move || eventjs.remove(e.doc, r + "move", e.onPointerMove), !e.onPointerUp || t && !t.up || eventjs.remove(e.doc, r + "up", e.onPointerUp), n = e.fingers, e.fingers = 0 }, t.resume = function (t) { !e.onPointerMove || t && !t.move || eventjs.add(e.doc, r + "move", e.onPointerMove), !e.onPointerUp || t && !t.up || eventjs.add(e.doc, r + "up", e.onPointerUp), e.fingers = n }, t.reset = function () { e.tracker = {}, e.fingers = 0 }, t }; var t = eventjs.supports; eventjs.isMouse = !!t.mouse, eventjs.isMSPointer = !!t.touch, eventjs.isTouch = !!t.msPointer, e.pointerStart = function (t, n, r) { var o = (t.type || "mousedown").toUpperCase(); 0 === o.indexOf("MOUSE") ? (eventjs.isMouse = !0, eventjs.isTouch = !1, eventjs.isMSPointer = !1) : 0 === o.indexOf("TOUCH") ? (eventjs.isMouse = !1, eventjs.isTouch = !0, eventjs.isMSPointer = !1) : 0 === o.indexOf("MSPOINTER") && (eventjs.isMouse = !1, eventjs.isTouch = !1, eventjs.isMSPointer = !0); var i = function (e, t) { var n = r.bbox, o = a[t] = {}; switch (r.position) { case "absolute": o.offsetX = 0, o.offsetY = 0; break; case "differenceFromLast": o.offsetX = e.pageX, o.offsetY = e.pageY; break; case "difference": o.offsetX = e.pageX, o.offsetY = e.pageY; break; case "move": o.offsetX = e.pageX - n.x1, o.offsetY = e.pageY - n.y1; break; default: o.offsetX = n.x1 - n.scrollLeft, o.offsetY = n.y1 - n.scrollTop } var i = e.pageX - o.offsetX, s = e.pageY - o.offsetY; o.rotation = 0, o.scale = 1, o.startTime = o.moveTime = (new Date).getTime(), o.move = { x: i, y: s }, o.start = { x: i, y: s }, r.fingers++ }; r.event = t, n.defaultListener && (r.listener = n.defaultListener, delete n.defaultListener); for (var s = !r.fingers, a = r.tracker, u = t.changedTouches || e.getCoords(t), c = u.length, f = 0; c > f; f++) { var v = u[f], d = v.identifier || 1 / 0; if (r.fingers) { if (r.fingers >= r.maxFingers) { var l = []; for (var d in r.tracker) l.push(d); return n.identifier = l.join(","), s } var p = 0; for (var g in a) { if (a[g].up) { delete a[g], i(v, d), r.cancel = !0; break } p++ } if (a[d]) continue; i(v, d) } else a = r.tracker = {}, n.bbox = r.bbox = e.getBoundingBox(r.target), r.fingers = 0, r.cancel = !1, i(v, d) } var l = []; for (var d in r.tracker) l.push(d); return n.identifier = l.join(","), s }, e.pointerEnd = function (e, t, n, r) { for (var o = e.touches || [], i = o.length, s = {}, a = 0; i > a; a++) { var u = o[a], c = u.identifier; s[c || 1 / 0] = !0 } for (var c in n.tracker) { var f = n.tracker[c]; s[c] || f.up || (r && r({ pageX: f.pageX, pageY: f.pageY, changedTouches: [{ pageX: f.pageX, pageY: f.pageY, identifier: "Infinity" === c ? 1 / 0 : c }] }, "up"), f.up = !0, n.fingers--) } if (0 !== n.fingers) return !1; var v = []; n.gestureFingers = 0; for (var c in n.tracker) n.gestureFingers++, v.push(c); return t.identifier = v.join(","), !0 }, e.getCoords = function (t) { return e.getCoords = "undefined" != typeof t.pageX ? function (e) { return Array({ type: "mouse", x: e.pageX, y: e.pageY, pageX: e.pageX, pageY: e.pageY, identifier: e.pointerId || 1 / 0 }) } : function (e) { var t = document.documentElement; return e = e || window.event, Array({ type: "mouse", x: e.clientX + t.scrollLeft, y: e.clientY + t.scrollTop, pageX: e.clientX + t.scrollLeft, pageY: e.clientY + t.scrollTop, identifier: 1 / 0 }) }, e.getCoords(t) }, e.getCoord = function (t) { if ("ontouchstart" in window) { var n = 0, r = 0; e.getCoord = function (e) { var t = e.changedTouches; return t && t.length ? { x: n = t[0].pageX, y: r = t[0].pageY } : { x: n, y: r } } } else e.getCoord = "undefined" != typeof t.pageX && "undefined" != typeof t.pageY ? function (e) { return { x: e.pageX, y: e.pageY } } : function (e) { var t = document.documentElement; return e = e || window.event, { x: e.clientX + t.scrollLeft, y: e.clientY + t.scrollTop } }; return e.getCoord(t) }; var n = function (e, t) { var n = parseFloat(e.getPropertyValue(t), 10); return isFinite(n) ? n : 0 }; return e.getBoundingBox = function (e) { (e === window || e === document) && (e = document.body); var t = {}, r = e.getBoundingClientRect(); t.width = r.width, t.height = r.height, t.x1 = r.left, t.y1 = r.top, t.scaleX = r.width / e.offsetWidth || 1, t.scaleY = r.height / e.offsetHeight || 1, t.scrollLeft = 0, t.scrollTop = 0; var o = window.getComputedStyle(e), i = "border-box" === o.getPropertyValue("box-sizing"); if (i === !1) { var s = n(o, "border-left-width"), a = n(o, "border-right-width"), u = n(o, "border-bottom-width"), c = n(o, "border-top-width"); t.border = [s, a, c, u], t.x1 += s, t.y1 += c, t.width -= a + s, t.height -= u + c } t.x2 = t.x1 + t.width, t.y2 = t.y1 + t.height; for (var f = o.getPropertyValue("position"), v = "fixed" === f ? e : e.parentNode; null !== v && v !== document.body && void 0 !== v.scrollTop;) { var o = window.getComputedStyle(v), f = o.getPropertyValue("position"); if ("absolute" === f); else { if ("fixed" === f) { t.scrollTop -= v.parentNode.scrollTop, t.scrollLeft -= v.parentNode.scrollLeft; break } t.scrollLeft += v.scrollLeft, t.scrollTop += v.scrollTop } v = v.parentNode } return t.scrollBodyLeft = void 0 !== window.pageXOffset ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft, t.scrollBodyTop = void 0 !== window.pageYOffset ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop, t.scrollLeft -= t.scrollBodyLeft, t.scrollTop -= t.scrollBodyTop, t }, function () { var t, n = navigator.userAgent.toLowerCase(), r = -1 !== n.indexOf("macintosh"); t = r && -1 !== n.indexOf("khtml") ? { 91: !0, 93: !0 } : r && -1 !== n.indexOf("firefox") ? { 224: !0 } : { 17: !0 }, (e.metaTrackerReset = function () { eventjs.fnKey = e.fnKey = !1, eventjs.metaKey = e.metaKey = !1, eventjs.escKey = e.escKey = !1, eventjs.ctrlKey = e.ctrlKey = !1, eventjs.shiftKey = e.shiftKey = !1, eventjs.altKey = e.altKey = !1 })(), e.metaTracker = function (n) { var r = "keydown" === n.type; 27 === n.keyCode && (eventjs.escKey = e.escKey = r), t[n.keyCode] && (eventjs.metaKey = e.metaKey = r), eventjs.ctrlKey = e.ctrlKey = n.ctrlKey, eventjs.shiftKey = e.shiftKey = n.shiftKey, eventjs.altKey = e.altKey = n.altKey } }(), e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if (eventjs.MutationObserver = function () { var e = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver, t = !e && function () { var e = document.createElement("p"), t = !1, n = function () { t = !0 }; if (e.addEventListener) e.addEventListener("DOMAttrModified", n, !1); else { if (!e.attachEvent) return !1; e.attachEvent("onDOMAttrModified", n) } return e.setAttribute("id", "target"), t }(); return function (n, r) { if (e) { var o = { subtree: !1, attributes: !0 }, i = new e(function (e) { e.forEach(function (e) { r.call(e.target, e.attributeName) }) }); i.observe(n, o) } else t ? eventjs.add(n, "DOMAttrModified", function (e) { r.call(n, e.attrName) }) : "onpropertychange" in document.body && eventjs.add(n, "propertychange", function () { r.call(n, window.event.propertyName) }) } }(), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; return e.click = function (t) { t.gesture = t.gesture || "click", t.maxFingers = t.maxFingers || t.fingers || 1, t.onPointerDown = function (r) { e.pointerStart(r, n, t) && eventjs.add(t.target, "mouseup", t.onPointerUp) }, t.onPointerUp = function (r) { if (e.pointerEnd(r, n, t)) { eventjs.remove(t.target, "mouseup", t.onPointerUp); var o = r.changedTouches || e.getCoords(r), i = o[0], s = t.bbox, a = e.getBoundingBox(t.target), u = i.pageY - a.scrollBodyTop, c = i.pageX - a.scrollBodyLeft; if (c > s.x1 && u > s.y1 && c < s.x2 && u < s.y2 && s.scrollTop === a.scrollTop) { for (var f in t.tracker) break; var v = t.tracker[f]; n.x = v.start.x, n.y = v.start.y, t.listener(r, n) } } }; var n = e.pointerSetup(t); return n.state = "click", eventjs.add(t.target, "mousedown", t.onPointerDown), n }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.click = e.click, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; return e.dbltap = e.dblclick = function (t) { t.gesture = t.gesture || "dbltap", t.maxFingers = t.maxFingers || t.fingers || 1; var n, r, o, i, s, a = 700; t.onPointerDown = function (c) { var f = c.changedTouches || e.getCoords(c); n && !r ? (s = f[0], r = (new Date).getTime() - n) : (i = f[0], n = (new Date).getTime(), r = 0, clearTimeout(o), o = setTimeout(function () { n = 0 }, a)), e.pointerStart(c, u, t) && (eventjs.add(t.target, "mousemove", t.onPointerMove).listener(c), eventjs.add(t.target, "mouseup", t.onPointerUp)) }, t.onPointerMove = function (a) { if (n && !r) { var u = a.changedTouches || e.getCoords(a); s = u[0] } var c = t.bbox, f = s.pageX - c.x1, v = s.pageY - c.y1; f > 0 && f < c.width && v > 0 && v < c.height && Math.abs(s.pageX - i.pageX) <= 25 && Math.abs(s.pageY - i.pageY) <= 25 || (eventjs.remove(t.target, "mousemove", t.onPointerMove), clearTimeout(o), n = r = 0) }, t.onPointerUp = function (i) { if (e.pointerEnd(i, u, t) && (eventjs.remove(t.target, "mousemove", t.onPointerMove), eventjs.remove(t.target, "mouseup", t.onPointerUp)), n && r) { if (a >= r) { u.state = t.gesture; for (var s in t.tracker) break; var c = t.tracker[s]; u.x = c.start.x, u.y = c.start.y, t.listener(i, u) } clearTimeout(o), n = r = 0 } }; var u = e.pointerSetup(t); return u.state = "dblclick", eventjs.add(t.target, "mousedown", t.onPointerDown), u }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.dbltap = e.dbltap, eventjs.Gesture._gestureHandlers.dblclick = e.dblclick, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; return e.dragElement = function (t, n) { e.drag({ event: n, target: t, position: "move", listener: function (e, n) { t.style.left = n.x + "px", t.style.top = n.y + "px", eventjs.prevent(e) } }) }, e.drag = function (t) { t.gesture = "drag", t.onPointerDown = function (r) { e.pointerStart(r, n, t) && (t.monitor || (eventjs.add(t.doc, "mousemove", t.onPointerMove), eventjs.add(t.doc, "mouseup", t.onPointerUp))), t.onPointerMove(r, "down") }, t.onPointerMove = function (r, o) { if (!t.tracker) return t.onPointerDown(r); for (var i = (t.bbox, r.changedTouches || e.getCoords(r)), s = i.length, a = 0; s > a; a++) { var u = i[a], c = u.identifier || 1 / 0, f = t.tracker[c]; f && (f.pageX = u.pageX, f.pageY = u.pageY, n.state = o || "move", n.identifier = c, n.start = f.start, n.fingers = t.fingers, "differenceFromLast" === t.position ? (n.x = f.pageX - f.offsetX, n.y = f.pageY - f.offsetY, f.offsetX = f.pageX, f.offsetY = f.pageY) : (n.x = f.pageX - f.offsetX, n.y = f.pageY - f.offsetY), t.listener(r, n)) } }, t.onPointerUp = function (r) { e.pointerEnd(r, n, t, t.onPointerMove) && (t.monitor || (eventjs.remove(t.doc, "mousemove", t.onPointerMove), eventjs.remove(t.doc, "mouseup", t.onPointerUp))) }; var n = e.pointerSetup(t); return t.event ? t.onPointerDown(t.event) : (eventjs.add(t.target, "mousedown", t.onPointerDown), t.monitor && (eventjs.add(t.doc, "mousemove", t.onPointerMove), eventjs.add(t.doc, "mouseup", t.onPointerUp))), n }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.drag = e.drag, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; var t = Math.PI / 180, n = function (e, t) { var n = 0, r = 0, o = 0; for (var i in t) { var s = t[i]; s.up || (n += s.move.x, r += s.move.y, o++) } return e.x = n /= o, e.y = r /= o, e }; return e.gesture = function (r) { r.gesture = r.gesture || "gesture", r.minFingers = r.minFingers || r.fingers || 2, r.onPointerDown = function (t) { var i = r.fingers; if (e.pointerStart(t, o, r) && (eventjs.add(r.doc, "mousemove", r.onPointerMove), eventjs.add(r.doc, "mouseup", r.onPointerUp)), r.fingers === r.minFingers && i !== r.fingers) { o.fingers = r.minFingers, o.scale = 1, o.rotation = 0, o.state = "start"; var s = ""; for (var a in r.tracker) s += a; o.identifier = parseInt(s), n(o, r.tracker), r.listener(t, o) } }, r.onPointerMove = function (i) { for (var s = r.bbox, a = r.tracker, u = i.changedTouches || e.getCoords(i), c = u.length, f = 0; c > f; f++) { var v = u[f], d = v.identifier || 1 / 0, l = a[d]; l && (l.move.x = v.pageX - s.x1, l.move.y = v.pageY - s.y1) } if (!(r.fingers < r.minFingers)) { var u = [], p = 0, g = 0; n(o, a); for (var d in a) { var v = a[d]; if (!v.up) { var m = v.start; if (!m.distance) { var y = m.x - o.x, h = m.y - o.y; m.distance = Math.sqrt(y * y + h * h), m.angle = Math.atan2(y, h) / t } var y = v.move.x - o.x, h = v.move.y - o.y, j = Math.sqrt(y * y + h * h); p += j / m.distance; var b = Math.atan2(y, h) / t, w = (m.angle - b + 360) % 360 - 180; v.DEG2 = v.DEG1, v.DEG1 = w > 0 ? w : -w, "undefined" != typeof v.DEG2 && (w > 0 ? v.rotation += v.DEG1 - v.DEG2 : v.rotation -= v.DEG1 - v.DEG2, g += v.rotation), u.push(v.move) } } o.touches = u, o.fingers = r.fingers, o.scale = p / r.fingers, o.rotation = g / r.fingers, o.state = "change", r.listener(i, o) } }, r.onPointerUp = function (t) { var n = r.fingers; e.pointerEnd(t, o, r) && (eventjs.remove(r.doc, "mousemove", r.onPointerMove), eventjs.remove(r.doc, "mouseup", r.onPointerUp)), n === r.minFingers && r.fingers < r.minFingers && (o.fingers = r.fingers, o.state = "end", r.listener(t, o)) }; var o = e.pointerSetup(r); return eventjs.add(r.target, "mousedown", r.onPointerDown), o }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.gesture = e.gesture, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; return e.pointerdown = e.pointermove = e.pointerup = function (t) { if (t.gesture = t.gesture || "pointer", !t.target.isPointerEmitter) { var n = !0; t.onPointerDown = function (e) { n = !1, r.gesture = "pointerdown", t.listener(e, r) }, t.onPointerMove = function (e) { r.gesture = "pointermove", t.listener(e, r, n) }, t.onPointerUp = function (e) { n = !0, r.gesture = "pointerup", t.listener(e, r, !0) }; var r = e.pointerSetup(t); return eventjs.add(t.target, "mousedown", t.onPointerDown), eventjs.add(t.target, "mousemove", t.onPointerMove), eventjs.add(t.doc, "mouseup", t.onPointerUp), t.target.isPointerEmitter = !0, r } }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.pointerdown = e.pointerdown, eventjs.Gesture._gestureHandlers.pointermove = e.pointermove, eventjs.Gesture._gestureHandlers.pointerup = e.pointerup, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; return e.shake = function (e) { var t = { gesture: "devicemotion", acceleration: {}, accelerationIncludingGravity: {}, target: e.target, listener: e.listener, remove: function () { window.removeEventListener("devicemotion", c, !1) } }, n = 4, r = 1e3, o = 200, i = 3, s = (new Date).getTime(), a = { x: 0, y: 0, z: 0 }, u = { x: { count: 0, value: 0 }, y: { count: 0, value: 0 }, z: { count: 0, value: 0 } }, c = function (c) { var f = .8, v = c.accelerationIncludingGravity; if (a.x = f * a.x + (1 - f) * v.x, a.y = f * a.y + (1 - f) * v.y, a.z = f * a.z + (1 - f) * v.z, t.accelerationIncludingGravity = a, t.acceleration.x = v.x - a.x, t.acceleration.y = v.y - a.y, t.acceleration.z = v.z - a.z, "devicemotion" === e.gesture) return void e.listener(c, t); for (var d = "xyz", l = (new Date).getTime(), p = 0, g = d.length; g > p; p++) { var m = d[p], y = t.acceleration[m], h = u[m], j = Math.abs(y); if (!(r > l - s) && j > n) { var b = l * y / j, w = Math.abs(b + h.value); h.value && o > w ? (h.value = b, h.count++, h.count === i && (e.listener(c, t), s = l, h.value = 0, h.count = 0)) : (h.value = b, h.count = 1) } } }; return window.addEventListener ? (window.addEventListener("devicemotion", c, !1), t) : void 0 }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.shake = e.shake, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; var t = Math.PI / 180; return e.swipe = function (n) { n.snap = n.snap || 90, n.threshold = n.threshold || 1, n.gesture = n.gesture || "swipe", n.onPointerDown = function (t) { e.pointerStart(t, r, n) && (eventjs.add(n.doc, "mousemove", n.onPointerMove).listener(t), eventjs.add(n.doc, "mouseup", n.onPointerUp)) }, n.onPointerMove = function (t) { for (var r = t.changedTouches || e.getCoords(t), o = r.length, i = 0; o > i; i++) { var s = r[i], a = s.identifier || 1 / 0, u = n.tracker[a]; u && (u.move.x = s.pageX, u.move.y = s.pageY, u.moveTime = (new Date).getTime()) } }, n.onPointerUp = function (o) { if (e.pointerEnd(o, r, n)) { eventjs.remove(n.doc, "mousemove", n.onPointerMove), eventjs.remove(n.doc, "mouseup", n.onPointerUp); var i, s, a, u, c = { x: 0, y: 0 }, f = 0, v = 0, d = 0; for (var l in n.tracker) { var p = n.tracker[l], g = p.move.x - p.start.x, m = p.move.y - p.start.y; f += p.move.x, v += p.move.y, c.x += p.start.x, c.y += p.start.y, d++; var y = Math.sqrt(g * g + m * m), h = p.moveTime - p.startTime, u = Math.atan2(g, m) / t + 180, s = h ? y / h : 0; if ("undefined" == typeof a) a = u, i = s; else { if (!(Math.abs(u - a) <= 20)) return; a = (a + u) / 2, i = (i + s) / 2 } } var j = n.gestureFingers; n.minFingers <= j && n.maxFingers >= j && i > n.threshold && (c.x /= d, c.y /= d, r.start = c, r.x = f / d, r.y = v / d, r.angle = -(((a / n.snap + .5 >> 0) * n.snap || 360) - 360), r.velocity = i, r.fingers = j, r.state = "swipe", n.listener(o, r)) } }; var r = e.pointerSetup(n); return eventjs.add(n.target, "mousedown", n.onPointerDown), r }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.swipe = e.swipe, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; return e.longpress = function (t) { return t.gesture = "longpress", e.tap(t) }, e.tap = function (t) { t.delay = t.delay || 500, t.timeout = t.timeout || 250, t.driftDeviance = t.driftDeviance || 10, t.gesture = t.gesture || "tap"; var n, r; t.onPointerDown = function (i) { if (e.pointerStart(i, o, t)) { if (n = (new Date).getTime(), eventjs.add(t.doc, "mousemove", t.onPointerMove).listener(i), eventjs.add(t.doc, "mouseup", t.onPointerUp), "longpress" !== t.gesture) return; r = setTimeout(function () { if (!(i.cancelBubble && ++i.cancelBubbleCount > 1)) { var e = 0; for (var n in t.tracker) { var r = t.tracker[n]; if (r.end === !0) return; if (t.cancel) return; e++ } t.minFingers <= e && t.maxFingers >= e && (o.state = "start", o.fingers = e, o.x = r.start.x, o.y = r.start.y, t.listener(i, o)) } }, t.delay) } }, t.onPointerMove = function (n) { for (var r = t.bbox, o = n.changedTouches || e.getCoords(n), i = o.length, s = 0; i > s; s++) { var a = o[s], u = a.identifier || 1 / 0, c = t.tracker[u]; if (c) { var f = a.pageX - r.x1, v = a.pageY - r.y1, d = f - c.start.x, l = v - c.start.y, p = Math.sqrt(d * d + l * l); if (!(f > 0 && f < r.width && v > 0 && v < r.height && p <= t.driftDeviance)) return eventjs.remove(t.doc, "mousemove", t.onPointerMove), void (t.cancel = !0) } } }, t.onPointerUp = function (i) { if (e.pointerEnd(i, o, t)) { if (clearTimeout(r), eventjs.remove(t.doc, "mousemove", t.onPointerMove), eventjs.remove(t.doc, "mouseup", t.onPointerUp), i.cancelBubble && ++i.cancelBubbleCount > 1) return; if ("longpress" === t.gesture) return void ("start" === o.state && (o.state = "end", t.listener(i, o))); if (t.cancel) return; if ((new Date).getTime() - n > t.timeout) return; var s = t.gestureFingers; t.minFingers <= s && t.maxFingers >= s && (o.state = "tap", o.fingers = t.gestureFingers, t.listener(i, o)) } }; var o = e.pointerSetup(t); return eventjs.add(t.target, "mousedown", t.onPointerDown), o }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.tap = e.tap, eventjs.Gesture._gestureHandlers.longpress = e.longpress, e }(eventjs.proxy), "undefined" == typeof eventjs) var eventjs = {}; if ("undefined" == typeof eventjs.proxy && (eventjs.proxy = {}), eventjs.proxy = function (e) { "use strict"; return e.wheelPreventElasticBounce = function (e) { e && ("string" == typeof e && (e = document.querySelector(e)), eventjs.add(e, "wheel", function (e, t) { t.preventElasticBounce(), eventjs.stop(e) })) }, e.wheel = function (e) { var t, n = e.timeout || 150, r = 0, o = { gesture: "wheel", state: "start", wheelDelta: 0, target: e.target, listener: e.listener, preventElasticBounce: function (e) { var t = this.target, n = t.scrollTop, r = n + t.offsetHeight, o = t.scrollHeight; r === o && this.wheelDelta <= 0 ? eventjs.cancel(e) : 0 === n && this.wheelDelta >= 0 && eventjs.cancel(e), eventjs.stop(e) }, add: function () { e.target[s](u, i, !1) }, remove: function () { e.target[a](u, i, !1) } }, i = function (i) { i = i || window.event, o.state = r++ ? "change" : "start", o.wheelDelta = i.detail ? -20 * i.detail : i.wheelDelta, e.listener(i, o), clearTimeout(t), t = setTimeout(function () { r = 0, o.state = "end", o.wheelDelta = 0, e.listener(i, o) }, n) }, s = document.addEventListener ? "addEventListener" : "attachEvent", a = document.removeEventListener ? "removeEventListener" : "detachEvent", u = eventjs.getEventSupport("mousewheel") ? "mousewheel" : "DOMMouseScroll"; return e.target[s](u, i, !1), o }, eventjs.Gesture = eventjs.Gesture || {}, eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {}, eventjs.Gesture._gestureHandlers.wheel = e.wheel, e }(eventjs.proxy), "undefined" == typeof Event) var Event = {}; "undefined" == typeof Event.proxy && (Event.proxy = {}), Event.proxy = function (e) { "use strict"; return e.orientation = function (e) { var t = { gesture: "orientationchange", previous: null, current: window.orientation, target: e.target, listener: e.listener, remove: function () { window.removeEventListener("orientationchange", n, !1) } }, n = function (n) { return t.previous = t.current, t.current = window.orientation, null !== t.previous && t.previous != t.current ? void e.listener(n, t) : void 0 }; return window.DeviceOrientationEvent && window.addEventListener("orientationchange", n, !1), t }, Event.Gesture = Event.Gesture || {}, Event.Gesture._gestureHandlers = Event.Gesture._gestureHandlers || {}, Event.Gesture._gestureHandlers.orientation = e.orientation, e }(Event.proxy); !function () { function e(e, t) { if (this.__eventListeners[e]) { var i = this.__eventListeners[e]; t ? i[i.indexOf(t)] = !1 : fabric.util.array.fill(i, !1) } } function t(e, t) { if (this.__eventListeners || (this.__eventListeners = {}), 1 === arguments.length) for (var i in e) this.on(i, e[i]); else this.__eventListeners[e] || (this.__eventListeners[e] = []), this.__eventListeners[e].push(t); return this } function i(t, i) { if (this.__eventListeners) { if (0 === arguments.length) for (t in this.__eventListeners) e.call(this, t); else if (1 === arguments.length && "object" == typeof arguments[0]) for (var n in t) e.call(this, n, t[n]); else e.call(this, t, i); return this } } function n(e, t) { if (this.__eventListeners) { var i = this.__eventListeners[e]; if (i) { for (var n = 0, r = i.length; r > n; n++) i[n] && i[n].call(this, t || {}); return this.__eventListeners[e] = i.filter(function (e) { return e !== !1 }), this } } } fabric.Observable = { observe: t, stopObserving: i, fire: n, on: t, off: i, trigger: n } }(); fabric.Collection = { _objects: [], add: function () { if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var t = 0, e = arguments.length; e > t; t++) this._onObjectAdded(arguments[t]); return this.renderOnAddRemove && this.renderAll(), this }, insertAt: function (t, e, n) { var i = this.getObjects(); return n ? i[e] = t : i.splice(e, 0, t), this._onObjectAdded && this._onObjectAdded(t), this.renderOnAddRemove && this.renderAll(), this }, remove: function () { for (var t, e = this.getObjects(), n = !1, i = 0, r = arguments.length; r > i; i++) t = e.indexOf(arguments[i]), -1 !== t && (n = !0, e.splice(t, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[i])); return this.renderOnAddRemove && n && this.renderAll(), this }, forEachObject: function (t, e) { for (var n = this.getObjects(), i = 0, r = n.length; r > i; i++) t.call(e, n[i], i, n); return this }, getObjects: function (t) { return "undefined" == typeof t ? this._objects : this._objects.filter(function (e) { return e.type === t }) }, item: function (t) { return this.getObjects()[t] }, isEmpty: function () { return 0 === this.getObjects().length }, size: function () { return this.getObjects().length }, contains: function (t) { return this.getObjects().indexOf(t) > -1 }, complexity: function () { return this.getObjects().reduce(function (t, e) { return t += e.complexity ? e.complexity() : 0 }, 0) } }; fabric.CommonMethods = { _setOptions: function (t) { for (var e in t) this.set(e, t[e]) }, _initGradient: function (t, e) { !t || !t.colorStops || t instanceof fabric.Gradient || this.set(e, new fabric.Gradient(t)) }, _initPattern: function (t, e, i) { !t || !t.source || t instanceof fabric.Pattern ? i && i() : this.set(e, new fabric.Pattern(t, i)) }, _initClipping: function (t) { if (t.clipTo && "string" == typeof t.clipTo) { var e = fabric.util.getFunctionBody(t.clipTo); "undefined" != typeof e && (this.clipTo = new Function("ctx", e)) } }, _setObject: function (t) { for (var e in t) this._set(e, t[e]) }, set: function (t, e) { return "object" == typeof t ? this._setObject(t) : "function" == typeof e && "clipTo" !== t ? this._set(t, e(this.get(t))) : this._set(t, e), this }, _set: function (t, e) { this[t] = e }, toggle: function (t) { var e = this.get(t); return "boolean" == typeof e && this.set(t, !e), this }, get: function (t) { return this[t] } }; !function (t) { var e = Math.sqrt, n = Math.atan2, r = Math.pow, i = Math.abs, o = Math.PI / 180; fabric.util = { removeFromArray: function (t, e) { var n = t.indexOf(e); return -1 !== n && t.splice(n, 1), t }, getRandomInt: function (t, e) { return Math.floor(Math.random() * (e - t + 1)) + t }, degreesToRadians: function (t) { return t * o }, radiansToDegrees: function (t) { return t / o }, rotatePoint: function (t, e, n) { t.subtractEquals(e); var r = fabric.util.rotateVector(t, n); return new fabric.Point(r.x, r.y).addEquals(e) }, rotateVector: function (t, e) { var n = Math.sin(e), r = Math.cos(e), i = t.x * r - t.y * n, o = t.x * n + t.y * r; return { x: i, y: o } }, transformPoint: function (t, e, n) { return n ? new fabric.Point(e[0] * t.x + e[2] * t.y, e[1] * t.x + e[3] * t.y) : new fabric.Point(e[0] * t.x + e[2] * t.y + e[4], e[1] * t.x + e[3] * t.y + e[5]) }, makeBoundingBoxFromPoints: function (t) { var e = [t[0].x, t[1].x, t[2].x, t[3].x], n = fabric.util.array.min(e), r = fabric.util.array.max(e), i = Math.abs(n - r), o = [t[0].y, t[1].y, t[2].y, t[3].y], a = fabric.util.array.min(o), c = fabric.util.array.max(o), s = Math.abs(a - c); return { left: n, top: a, width: i, height: s } }, invertTransform: function (t) { var e = 1 / (t[0] * t[3] - t[1] * t[2]), n = [e * t[3], -e * t[1], -e * t[2], e * t[0]], r = fabric.util.transformPoint({ x: t[4], y: t[5] }, n, !0); return n[4] = -r.x, n[5] = -r.y, n }, toFixed: function (t, e) { return parseFloat(Number(t).toFixed(e)) }, parseUnit: function (t, e) { var n = /\D{0,2}$/.exec(t), r = parseFloat(t); switch (e || (e = fabric.Text.DEFAULT_SVG_FONT_SIZE), n[0]) { case "mm": return r * fabric.DPI / 25.4; case "cm": return r * fabric.DPI / 2.54; case "in": return r * fabric.DPI; case "pt": return r * fabric.DPI / 72; case "pc": return r * fabric.DPI / 72 * 12; case "em": return r * e; default: return r } }, falseFunction: function () { return !1 }, getKlass: function (t, e) { return t = fabric.util.string.camelize(t.charAt(0).toUpperCase() + t.slice(1)), fabric.util.resolveNamespace(e)[t] }, resolveNamespace: function (e) { if (!e) return fabric; var n, r = e.split("."), i = r.length, o = t || fabric.window; for (n = 0; i > n; ++n) o = o[r[n]]; return o }, loadImage: function (t, e, n, r) { if (!t) return void (e && e.call(n, t)); var i = fabric.util.createImage(); i.onload = function () { e && e.call(n, i), i = i.onload = i.onerror = null }, i.onerror = function () { fabric.log("Error loading " + i.src), e && e.call(n, null, !0), i = i.onload = i.onerror = null }, 0 !== t.indexOf("data") && r && (i.crossOrigin = r), i.src = t }, enlivenObjects: function (t, e, n, r) { function i() { ++a === c && e && e(o) } t = t || []; var o = [], a = 0, c = t.length, s = !0; return c ? void t.forEach(function (t, e) { if (!t || !t.type) return void i(); var a = fabric.util.getKlass(t.type, n); a.fromObject(t, function (n, a) { a || (o[e] = n), r && r(t, n, a), i() }, s) }) : void (e && e(o)) }, enlivenPatterns: function (t, e) { function n() { ++i === o && e && e(r) } t = t || []; var r = [], i = 0, o = t.length; return o ? void t.forEach(function (t, e) { t && t.source ? new fabric.Pattern(t, function (t) { r[e] = t, n() }) : (r[e] = t, n()) }) : void (e && e(r)) }, groupSVGElements: function (t, e, n) { var r; return r = new fabric.PathGroup(t, e), "undefined" != typeof n && r.setSourcePath(n), r }, populateWithProperties: function (t, e, n) { if (n && "[object Array]" === Object.prototype.toString.call(n)) for (var r = 0, i = n.length; i > r; r++) n[r] in t && (e[n[r]] = t[n[r]]) }, drawDashedLine: function (t, r, i, o, a, c) { var s = o - r, f = a - i, u = e(s * s + f * f), l = n(f, s), d = c.length, h = 0, b = !0; for (t.save(), t.translate(r, i), t.moveTo(0, 0), t.rotate(l), r = 0; u > r;) r += c[h++ % d], r > u && (r = u), t[b ? "lineTo" : "moveTo"](r, 0), b = !b; t.restore() }, createCanvasElement: function (t) { return t || (t = fabric.document.createElement("canvas")), t.getContext || "undefined" == typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(t), t }, createImage: function () { return fabric.isLikelyNode ? new (require("canvas").Image) : fabric.document.createElement("img") }, createAccessors: function (t) { var e, n, r, i, o, a = t.prototype; for (e = a.stateProperties.length; e--;) n = a.stateProperties[e], r = n.charAt(0).toUpperCase() + n.slice(1), i = "set" + r, o = "get" + r, a[o] || (a[o] = function (t) { return new Function('return this.get("' + t + '")') }(n)), a[i] || (a[i] = function (t) { return new Function("value", 'return this.set("' + t + '", value)') }(n)) }, clipContext: function (t, e) { e.save(), e.beginPath(), t.clipTo(e), e.clip() }, multiplyTransformMatrices: function (t, e, n) { return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], n ? 0 : t[0] * e[4] + t[2] * e[5] + t[4], n ? 0 : t[1] * e[4] + t[3] * e[5] + t[5]] }, qrDecompose: function (t) { var i = n(t[1], t[0]), a = r(t[0], 2) + r(t[1], 2), c = e(a), s = (t[0] * t[3] - t[2] * t[1]) / c, f = n(t[0] * t[2] + t[1] * t[3], a); return { angle: i / o, scaleX: c, scaleY: s, skewX: f / o, skewY: 0, translateX: t[4], translateY: t[5] } }, customTransformMatrix: function (t, e, n) { var r = [1, 0, i(Math.tan(n * o)), 1], a = [i(t), 0, 0, i(e)]; return fabric.util.multiplyTransformMatrices(a, r, !0) }, resetObjectTransform: function (t) { t.scaleX = 1, t.scaleY = 1, t.skewX = 0, t.skewY = 0, t.flipX = !1, t.flipY = !1, t.setAngle(0) }, getFunctionBody: function (t) { return (String(t).match(/function[^{]*\{([\s\S]*)\}/) || {})[1] }, isTransparent: function (t, e, n, r) { r > 0 && (e > r ? e -= r : e = 0, n > r ? n -= r : n = 0); var i, o, a = !0, c = t.getImageData(e, n, 2 * r || 1, 2 * r || 1), s = c.data.length; for (i = 3; s > i && (o = c.data[i], a = 0 >= o, a !== !1) ; i += 4); return c = null, a }, parsePreserveAspectRatioAttribute: function (t) { var e, n = "meet", r = "Mid", i = "Mid", o = t.split(" "); return o && o.length && (n = o.pop(), "meet" !== n && "slice" !== n ? (e = n, n = "meet") : o.length && (e = o.pop())), r = "none" !== e ? e.slice(1, 4) : "none", i = "none" !== e ? e.slice(5, 8) : "none", { meetOrSlice: n, alignX: r, alignY: i } }, clearFabricFontCache: function (t) { t ? fabric.charWidthsCache[t] && delete fabric.charWidthsCache[t] : fabric.charWidthsCache = {} } } }("undefined" != typeof exports ? exports : this); !function () { function e(e, r, i, s, u, c, f) { var v = a.call(arguments); if (o[v]) return o[v]; var d = Math.PI, l = f * d / 180, p = Math.sin(l), g = Math.cos(l), m = 0, h = 0; i = Math.abs(i), s = Math.abs(s); var y = -g * e * .5 - p * r * .5, j = -g * r * .5 + p * e * .5, b = i * i, w = s * s, x = j * j, P = y * y, M = b * w - b * x - w * P, E = 0; if (0 > M) { var T = Math.sqrt(1 - M / (b * w)); i *= T, s *= T } else E = (u === c ? -1 : 1) * Math.sqrt(M / (b * x + w * P)); var _ = E * i * j / s, L = -E * s * y / i, G = g * _ - p * L + .5 * e, D = p * _ + g * L + .5 * r, O = n(1, 0, (y - _) / i, (j - L) / s), k = n((y - _) / i, (j - L) / s, (-y - _) / i, (-j - L) / s); 0 === c && k > 0 ? k -= 2 * d : 1 === c && 0 > k && (k += 2 * d); for (var C = Math.ceil(Math.abs(k / d * 2)), F = [], S = k / C, X = 8 / 3 * Math.sin(S / 4) * Math.sin(S / 4) / Math.sin(S / 2), Y = O + S, H = 0; C > H; H++) F[H] = t(O, Y, g, p, i, s, G, D, X, m, h), m = F[H][4], h = F[H][5], O = Y, Y += S; return o[v] = F, F } function t(e, t, n, r, o, s, u, c, f, v, d) { var l = a.call(arguments); if (i[l]) return i[l]; var p = Math.cos(e), g = Math.sin(e), m = Math.cos(t), h = Math.sin(t), y = n * o * m - r * s * h + u, j = r * o * m + n * s * h + c, b = v + f * (-n * o * g - r * s * p), w = d + f * (-r * o * g + n * s * p), x = y + f * (n * o * h + r * s * m), P = j + f * (r * o * h - n * s * m); return i[l] = [b, w, x, P, y, j], i[l] } function n(e, t, n, r) { var o = Math.atan2(t, e), i = Math.atan2(r, n); return i >= o ? i - o : 2 * Math.PI - (o - i) } function r(e, t, n, r, o, i, u, c) { var f = a.call(arguments); if (s[f]) return s[f]; var v, d, l, p, g, m, h, y, j = Math.sqrt, b = Math.min, w = Math.max, x = Math.abs, P = [], M = [[], []]; d = 6 * e - 12 * n + 6 * o, v = -3 * e + 9 * n - 9 * o + 3 * u, l = 3 * n - 3 * e; for (var E = 0; 2 > E; ++E) if (E > 0 && (d = 6 * t - 12 * r + 6 * i, v = -3 * t + 9 * r - 9 * i + 3 * c, l = 3 * r - 3 * t), x(v) < 1e-12) { if (x(d) < 1e-12) continue; p = -l / d, p > 0 && 1 > p && P.push(p) } else h = d * d - 4 * l * v, 0 > h || (y = j(h), g = (-d + y) / (2 * v), g > 0 && 1 > g && P.push(g), m = (-d - y) / (2 * v), m > 0 && 1 > m && P.push(m)); for (var T, _, L, G = P.length, D = G; G--;) p = P[G], L = 1 - p, T = L * L * L * e + 3 * L * L * p * n + 3 * L * p * p * o + p * p * p * u, M[0][G] = T, _ = L * L * L * t + 3 * L * L * p * r + 3 * L * p * p * i + p * p * p * c, M[1][G] = _; M[0][D] = e, M[1][D] = t, M[0][D + 1] = u, M[1][D + 1] = c; var O = [{ x: b.apply(null, M[0]), y: b.apply(null, M[1]) }, { x: w.apply(null, M[0]), y: w.apply(null, M[1]) }]; return s[f] = O, O } var o = {}, i = {}, s = {}, a = Array.prototype.join; fabric.util.drawArc = function (t, n, r, o) { for (var i = o[0], s = o[1], a = o[2], u = o[3], c = o[4], f = o[5], v = o[6], d = [[], [], [], []], l = e(f - n, v - r, i, s, u, c, a), p = 0, g = l.length; g > p; p++) d[p][0] = l[p][0] + n, d[p][1] = l[p][1] + r, d[p][2] = l[p][2] + n, d[p][3] = l[p][3] + r, d[p][4] = l[p][4] + n, d[p][5] = l[p][5] + r, t.bezierCurveTo.apply(t, d[p]) }, fabric.util.getBoundsOfArc = function (t, n, o, i, s, a, u, c, f) { for (var v, d = 0, l = 0, p = [], g = e(c - t, f - n, o, i, a, u, s), m = 0, h = g.length; h > m; m++) v = r(d, l, g[m][0], g[m][1], g[m][2], g[m][3], g[m][4], g[m][5]), p.push({ x: v[0].x + t, y: v[0].y + n }), p.push({ x: v[1].x + t, y: v[1].y + n }), d = g[m][4], l = g[m][5]; return p }, fabric.util.getBoundsOfCurve = r }(); !function () { function e(e, t) { for (var n = i.call(arguments, 2), r = [], o = 0, s = e.length; s > o; o++) r[o] = n.length ? e[o][t].apply(e[o], n) : e[o][t].call(e[o]); return r } function t(e, t) { return o(e, t, function (e, t) { return e >= t }) } function n(e, t) { return o(e, t, function (e, t) { return t > e }) } function r(e, t) { for (var n = e.length; n--;) e[n] = t; return e } function o(e, t, n) { if (e && 0 !== e.length) { var r = e.length - 1, o = t ? e[r][t] : e[r]; if (t) for (; r--;) n(e[r][t], o) && (o = e[r][t]); else for (; r--;) n(e[r], o) && (o = e[r]); return o } } var i = Array.prototype.slice; Array.prototype.indexOf || (Array.prototype.indexOf = function (e) { if (void 0 === this || null === this) throw new TypeError; var t = Object(this), n = t.length >>> 0; if (0 === n) return -1; var r = 0; if (arguments.length > 0 && (r = Number(arguments[1]), r !== r ? r = 0 : 0 !== r && r !== Number.POSITIVE_INFINITY && r !== Number.NEGATIVE_INFINITY && (r = (r > 0 || -1) * Math.floor(Math.abs(r)))), r >= n) return -1; for (var o = r >= 0 ? r : Math.max(n - Math.abs(r), 0) ; n > o; o++) if (o in t && t[o] === e) return o; return -1 }), Array.prototype.forEach || (Array.prototype.forEach = function (e, t) { for (var n = 0, r = this.length >>> 0; r > n; n++) n in this && e.call(t, this[n], n, this) }), Array.prototype.map || (Array.prototype.map = function (e, t) { for (var n = [], r = 0, o = this.length >>> 0; o > r; r++) r in this && (n[r] = e.call(t, this[r], r, this)); return n }), Array.prototype.every || (Array.prototype.every = function (e, t) { for (var n = 0, r = this.length >>> 0; r > n; n++) if (n in this && !e.call(t, this[n], n, this)) return !1; return !0 }), Array.prototype.some || (Array.prototype.some = function (e, t) { for (var n = 0, r = this.length >>> 0; r > n; n++) if (n in this && e.call(t, this[n], n, this)) return !0; return !1 }), Array.prototype.filter || (Array.prototype.filter = function (e, t) { for (var n, r = [], o = 0, i = this.length >>> 0; i > o; o++) o in this && (n = this[o], e.call(t, n, o, this) && r.push(n)); return r }), Array.prototype.reduce || (Array.prototype.reduce = function (e) { var t, n = this.length >>> 0, r = 0; if (arguments.length > 1) t = arguments[1]; else for (; ;) { if (r in this) { t = this[r++]; break } if (++r >= n) throw new TypeError } for (; n > r; r++) r in this && (t = e.call(null, t, this[r], r, this)); return t }), fabric.util.array = { fill: r, invoke: e, min: n, max: t } }(); !function () { function e(t, n, r) { if (r) if (!fabric.isLikelyNode && n instanceof Element) t = n; else if (n instanceof Array) { t = []; for (var o = 0, i = n.length; i > o; o++) t[o] = e({}, n[o], r) } else if (n && "object" == typeof n) for (var s in n) n.hasOwnProperty(s) && (t[s] = e({}, n[s], r)); else t = n; else for (var s in n) t[s] = n[s]; return t } function t(t, n) { return e({}, t, n) } fabric.util.object = { extend: e, clone: t } }(); !function () { function e(e) { return e.replace(/-+(.)?/g, function (e, t) { return t ? t.toUpperCase() : "" }) } function t(e, t) { return e.charAt(0).toUpperCase() + (t ? e.slice(1) : e.slice(1).toLowerCase()) } function n(e) { return e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } String.prototype.trim || (String.prototype.trim = function () { return this.replace(/^[\s\xA0]+/, "").replace(/[\s\xA0]+$/, "") }), fabric.util.string = { camelize: e, capitalize: t, escapeXml: n } }(); !function () { var e = Array.prototype.slice, t = Function.prototype.apply, n = function () { }; Function.prototype.bind || (Function.prototype.bind = function (r) { var o, i = this, s = e.call(arguments, 1); return o = s.length ? function () { return t.call(i, this instanceof n ? this : r, s.concat(e.call(arguments))) } : function () { return t.call(i, this instanceof n ? this : r, arguments) }, n.prototype = this.prototype, o.prototype = new n, o }) }(); !function () { function e() { } function t(e) { var t = this.constructor.superclass.prototype[e]; return arguments.length > 1 ? t.apply(this, r.call(arguments, 1)) : t.call(this) } function n() { function n() { this.initialize.apply(this, arguments) } var i = null, a = r.call(arguments, 0); "function" == typeof a[0] && (i = a.shift()), n.superclass = i, n.subclasses = [], i && (e.prototype = i.prototype, n.prototype = new e, i.subclasses.push(n)); for (var u = 0, c = a.length; c > u; u++) s(n, a[u], i); return n.prototype.initialize || (n.prototype.initialize = o), n.prototype.constructor = n, n.prototype.callSuper = t, n } var r = Array.prototype.slice, o = function () { }, i = function () { for (var e in { toString: 1 }) if ("toString" === e) return !1; return !0 }(), s = function (e, t, n) { for (var r in t) e.prototype[r] = r in e.prototype && "function" == typeof e.prototype[r] && (t[r] + "").indexOf("callSuper") > -1 ? function (e) { return function () { var r = this.constructor.superclass; this.constructor.superclass = n; var o = t[e].apply(this, arguments); return this.constructor.superclass = r, "initialize" !== e ? o : void 0 } }(r) : t[r], i && (t.toString !== Object.prototype.toString && (e.prototype.toString = t.toString), t.valueOf !== Object.prototype.valueOf && (e.prototype.valueOf = t.valueOf)) }; fabric.util.createClass = n }(); !function () { function e(e) { var t, n, r = Array.prototype.slice.call(arguments, 1), o = r.length; for (n = 0; o > n; n++) if (t = typeof e[r[n]], !/^(?:function|object|unknown)$/.test(t)) return !1; return !0 } function t(e, t) { return { handler: t, wrappedHandler: n(e, t) } } function n(e, t) { return function (n) { t.call(a(e), n || fabric.window.event) } } function r(e, t) { return function (n) { if (g[e] && g[e][t]) for (var r = g[e][t], o = 0, i = r.length; i > o; o++) r[o].call(this, n || fabric.window.event) } } function o(e) { e || (e = fabric.window.event); var t = e.target || (typeof e.srcElement !== u ? e.srcElement : null), n = fabric.util.getScrollLeftTop(t); return { x: m(e) + n.left, y: y(e) + n.top } } function i(e, t, n) { var r = "touchend" === e.type ? "changedTouches" : "touches"; return e[r] && e[r][0] ? e[r][0][t] - (e[r][0][t] - e[r][0][n]) || e[n] : e[n] } var a, s, u = "unknown", c = function () { var e = 0; return function (t) { return t.__uniqueID || (t.__uniqueID = "uniqueID__" + e++) } }(); !function () { var e = {}; a = function (t) { return e[t] }, s = function (t, n) { e[t] = n } }(); var f, l, d = e(fabric.document.documentElement, "addEventListener", "removeEventListener") && e(fabric.window, "addEventListener", "removeEventListener"), v = e(fabric.document.documentElement, "attachEvent", "detachEvent") && e(fabric.window, "attachEvent", "detachEvent"), p = {}, g = {}; d ? (f = function (e, t, n, r) { e.addEventListener(t, n, v ? !1 : r) }, l = function (e, t, n, r) { e.removeEventListener(t, n, v ? !1 : r) }) : v ? (f = function (e, n, r) { var o = c(e); s(o, e), p[o] || (p[o] = {}), p[o][n] || (p[o][n] = []); var i = t(o, r); p[o][n].push(i), e.attachEvent("on" + n, i.wrappedHandler) }, l = function (e, t, n) { var r, o = c(e); if (p[o] && p[o][t]) for (var i = 0, a = p[o][t].length; a > i; i++) r = p[o][t][i], r && r.handler === n && (e.detachEvent("on" + t, r.wrappedHandler), p[o][t][i] = null) }) : (f = function (e, t, n) { var o = c(e); if (g[o] || (g[o] = {}), !g[o][t]) { g[o][t] = []; var i = e["on" + t]; i && g[o][t].push(i), e["on" + t] = r(o, t) } g[o][t].push(n) }, l = function (e, t, n) { var r = c(e); if (g[r] && g[r][t]) for (var o = g[r][t], i = 0, a = o.length; a > i; i++) o[i] === n && o.splice(i, 1) }), fabric.util.addListener = f, fabric.util.removeListener = l; var m = function (e) { return typeof e.clientX !== u ? e.clientX : 0 }, y = function (e) { return typeof e.clientY !== u ? e.clientY : 0 }; fabric.isTouchSupported && (m = function (e) { return i(e, "pageX", "clientX") }, y = function (e) { return i(e, "pageY", "clientY") }), fabric.util.getPointer = o, fabric.util.object.extend(fabric.util, fabric.Observable) }(); !function () { function e(e, t) { var n = e.style; if (!n) return e; if ("string" == typeof t) return e.style.cssText += ";" + t, t.indexOf("opacity") > -1 ? i(e, t.match(/opacity:\s*(\d?\.?\d*)/)[1]) : e; for (var r in t) if ("opacity" === r) i(e, t[r]); else { var o = "float" === r || "cssFloat" === r ? "undefined" == typeof n.styleFloat ? "cssFloat" : "styleFloat" : r; n[o] = t[r] } return e } var t = fabric.document.createElement("div"), n = "string" == typeof t.style.opacity, r = "string" == typeof t.style.filter, o = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, i = function (e) { return e }; n ? i = function (e, t) { return e.style.opacity = t, e } : r && (i = function (e, t) { var n = e.style; return e.currentStyle && !e.currentStyle.hasLayout && (n.zoom = 1), o.test(n.filter) ? (t = t >= .9999 ? "" : "alpha(opacity=" + 100 * t + ")", n.filter = n.filter.replace(o, t)) : n.filter += " alpha(opacity=" + 100 * t + ")", e }), fabric.util.setStyle = e }(); !function () { function e(e) { return "string" == typeof e ? fabric.document.getElementById(e) : e } function t(e, t) { var n = fabric.document.createElement(e); for (var r in t) "class" === r ? n.className = t[r] : "for" === r ? n.htmlFor = t[r] : n.setAttribute(r, t[r]); return n } function n(e, t) { e && -1 === (" " + e.className + " ").indexOf(" " + t + " ") && (e.className += (e.className ? " " : "") + t) } function r(e, n, r) { return "string" == typeof n && (n = t(n, r)), e.parentNode && e.parentNode.replaceChild(n, e), n.appendChild(e), n } function o(e) { for (var t = 0, n = 0, r = fabric.document.documentElement, o = fabric.document.body || { scrollLeft: 0, scrollTop: 0 }; e && (e.parentNode || e.host) && (e = e.parentNode || e.host, e === fabric.document ? (t = o.scrollLeft || r.scrollLeft || 0, n = o.scrollTop || r.scrollTop || 0) : (t += e.scrollLeft || 0, n += e.scrollTop || 0), 1 !== e.nodeType || "fixed" !== fabric.util.getElementStyle(e, "position")) ;); return { left: t, top: n } } function i(e) { var t, n, r = e && e.ownerDocument, i = { left: 0, top: 0 }, s = { left: 0, top: 0 }, a = { borderLeftWidth: "left", borderTopWidth: "top", paddingLeft: "left", paddingTop: "top" }; if (!r) return s; for (var u in a) s[a[u]] += parseInt(f(e, u), 10) || 0; return t = r.documentElement, "undefined" != typeof e.getBoundingClientRect && (i = e.getBoundingClientRect()), n = o(e), { left: i.left + n.left - (t.clientLeft || 0) + s.left, top: i.top + n.top - (t.clientTop || 0) + s.top } } var s, a = Array.prototype.slice, u = function (e) { return a.call(e, 0) }; try { s = u(fabric.document.childNodes) instanceof Array } catch (c) { } s || (u = function (e) { for (var t = new Array(e.length), n = e.length; n--;) t[n] = e[n]; return t }); var f; f = fabric.document.defaultView && fabric.document.defaultView.getComputedStyle ? function (e, t) { var n = fabric.document.defaultView.getComputedStyle(e, null); return n ? n[t] : void 0 } : function (e, t) { var n = e.style[t]; return !n && e.currentStyle && (n = e.currentStyle[t]), n }, function () { function e(e) { return "undefined" != typeof e.onselectstart && (e.onselectstart = fabric.util.falseFunction), r ? e.style[r] = "none" : "string" == typeof e.unselectable && (e.unselectable = "on"), e } function t(e) { return "undefined" != typeof e.onselectstart && (e.onselectstart = null), r ? e.style[r] = "" : "string" == typeof e.unselectable && (e.unselectable = ""), e } var n = fabric.document.documentElement.style, r = "userSelect" in n ? "userSelect" : "MozUserSelect" in n ? "MozUserSelect" : "WebkitUserSelect" in n ? "WebkitUserSelect" : "KhtmlUserSelect" in n ? "KhtmlUserSelect" : ""; fabric.util.makeElementUnselectable = e, fabric.util.makeElementSelectable = t }(), function () { function e(e, t) { var n = fabric.document.getElementsByTagName("head")[0], r = fabric.document.createElement("script"), o = !0; r.onload = r.onreadystatechange = function (e) { if (o) { if ("string" == typeof this.readyState && "loaded" !== this.readyState && "complete" !== this.readyState) return; o = !1, t(e || fabric.window.event), r = r.onload = r.onreadystatechange = null } }, r.src = e, n.appendChild(r) } fabric.util.getScript = e }(), fabric.util.getById = e, fabric.util.toArray = u, fabric.util.makeElement = t, fabric.util.addClass = n, fabric.util.wrapElement = r, fabric.util.getScrollLeftTop = o, fabric.util.getElementOffset = i, fabric.util.getElementStyle = f }(); !function () { function e(e, t) { return e + (/\?/.test(e) ? "&" : "?") + t } function t() { } function n(n, o) { o || (o = {}); var i = o.method ? o.method.toUpperCase() : "GET", s = o.onComplete || function () { }, a = r(), u = o.body || o.parameters; return a.onreadystatechange = function () { 4 === a.readyState && (s(a), a.onreadystatechange = t) }, "GET" === i && (u = null, "string" == typeof o.parameters && (n = e(n, o.parameters))), a.open(i, n, !0), ("POST" === i || "PUT" === i) && a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), a.send(u), a } var r = function () { for (var e = [function () { return new ActiveXObject("Microsoft.XMLHTTP") }, function () { return new ActiveXObject("Msxml2.XMLHTTP") }, function () { return new ActiveXObject("Msxml2.XMLHTTP.3.0") }, function () { return new XMLHttpRequest }], t = e.length; t--;) try { var n = e[t](); if (n) return e[t] } catch (r) { } }(); fabric.util.request = n }(); fabric.log = function () { }, fabric.warn = function () { }, "undefined" != typeof console && ["log", "warn"].forEach(function (e) { "undefined" != typeof console[e] && "function" == typeof console[e].apply && (fabric[e] = function () { return console[e].apply(console, arguments) }) }); !function (e) { "use strict"; function t(e, t) { this.x = e, this.y = t } var n = e.fabric || (e.fabric = {}); return n.Point ? void n.warn("fabric.Point is already defined") : (n.Point = t, void (t.prototype = { type: "point", constructor: t, add: function (e) { return new t(this.x + e.x, this.y + e.y) }, addEquals: function (e) { return this.x += e.x, this.y += e.y, this }, scalarAdd: function (e) { return new t(this.x + e, this.y + e) }, scalarAddEquals: function (e) { return this.x += e, this.y += e, this }, subtract: function (e) { return new t(this.x - e.x, this.y - e.y) }, subtractEquals: function (e) { return this.x -= e.x, this.y -= e.y, this }, scalarSubtract: function (e) { return new t(this.x - e, this.y - e) }, scalarSubtractEquals: function (e) { return this.x -= e, this.y -= e, this }, multiply: function (e) { return new t(this.x * e, this.y * e) }, multiplyEquals: function (e) { return this.x *= e, this.y *= e, this }, divide: function (e) { return new t(this.x / e, this.y / e) }, divideEquals: function (e) { return this.x /= e, this.y /= e, this }, eq: function (e) { return this.x === e.x && this.y === e.y }, lt: function (e) { return this.x < e.x && this.y < e.y }, lte: function (e) { return this.x <= e.x && this.y <= e.y }, gt: function (e) { return this.x > e.x && this.y > e.y }, gte: function (e) { return this.x >= e.x && this.y >= e.y }, lerp: function (e, n) { return "undefined" == typeof n && (n = .5), n = Math.max(Math.min(1, n), 0), new t(this.x + (e.x - this.x) * n, this.y + (e.y - this.y) * n) }, distanceFrom: function (e) { var t = this.x - e.x, n = this.y - e.y; return Math.sqrt(t * t + n * n) }, midPointFrom: function (e) { return this.lerp(e) }, min: function (e) { return new t(Math.min(this.x, e.x), Math.min(this.y, e.y)) }, max: function (e) { return new t(Math.max(this.x, e.x), Math.max(this.y, e.y)) }, toString: function () { return this.x + "," + this.y }, setXY: function (e, t) { return this.x = e, this.y = t, this }, setX: function (e) { return this.x = e, this }, setY: function (e) { return this.y = e, this }, setFromPoint: function (e) { return this.x = e.x, this.y = e.y, this }, swap: function (e) { var t = this.x, n = this.y; this.x = e.x, this.y = e.y, e.x = t, e.y = n }, clone: function () { return new t(this.x, this.y) } })) }("undefined" != typeof exports ? exports : this); !function (e) { "use strict"; function t(e) { this.status = e, this.points = [] } var n = e.fabric || (e.fabric = {}); return n.Intersection ? void n.warn("fabric.Intersection is already defined") : (n.Intersection = t, n.Intersection.prototype = { constructor: t, appendPoint: function (e) { return this.points.push(e), this }, appendPoints: function (e) { return this.points = this.points.concat(e), this } }, n.Intersection.intersectLineLine = function (e, r, o, i) { var s, a = (i.x - o.x) * (e.y - o.y) - (i.y - o.y) * (e.x - o.x), u = (r.x - e.x) * (e.y - o.y) - (r.y - e.y) * (e.x - o.x), c = (i.y - o.y) * (r.x - e.x) - (i.x - o.x) * (r.y - e.y); if (0 !== c) { var f = a / c, l = u / c; f >= 0 && 1 >= f && l >= 0 && 1 >= l ? (s = new t("Intersection"), s.appendPoint(new n.Point(e.x + f * (r.x - e.x), e.y + f * (r.y - e.y)))) : s = new t } else s = new t(0 === a || 0 === u ? "Coincident" : "Parallel"); return s }, n.Intersection.intersectLinePolygon = function (e, n, r) { for (var o, i, s, a = new t, u = r.length, c = 0; u > c; c++) o = r[c], i = r[(c + 1) % u], s = t.intersectLineLine(e, n, o, i), a.appendPoints(s.points); return a.points.length > 0 && (a.status = "Intersection"), a }, n.Intersection.intersectPolygonPolygon = function (e, n) { for (var r = new t, o = e.length, i = 0; o > i; i++) { var s = e[i], a = e[(i + 1) % o], u = t.intersectLinePolygon(s, a, n); r.appendPoints(u.points) } return r.points.length > 0 && (r.status = "Intersection"), r }, void (n.Intersection.intersectPolygonRectangle = function (e, r, o) { var i = r.min(o), s = r.max(o), a = new n.Point(s.x, i.y), u = new n.Point(i.x, s.y), c = t.intersectLinePolygon(i, a, e), f = t.intersectLinePolygon(a, s, e), l = t.intersectLinePolygon(s, u, e), d = t.intersectLinePolygon(u, i, e), v = new t; return v.appendPoints(c.points), v.appendPoints(f.points), v.appendPoints(l.points), v.appendPoints(d.points), v.points.length > 0 && (v.status = "Intersection"), v })) }("undefined" != typeof exports ? exports : this); !function (e) { "use strict"; function t(e) { e ? this._tryParsingColor(e) : this.setSource([0, 0, 0, 1]) } function n(e, t, n) { return 0 > n && (n += 1), n > 1 && (n -= 1), 1 / 6 > n ? e + 6 * (t - e) * n : .5 > n ? t : 2 / 3 > n ? e + (t - e) * (2 / 3 - n) * 6 : e } var r = e.fabric || (e.fabric = {}); return r.Color ? void r.warn("fabric.Color is already defined.") : (r.Color = t, r.Color.prototype = { _tryParsingColor: function (e) { var n; e in t.colorNameMap && (e = t.colorNameMap[e]), "transparent" === e && (n = [255, 255, 255, 0]), n || (n = t.sourceFromHex(e)), n || (n = t.sourceFromRgb(e)), n || (n = t.sourceFromHsl(e)), n || (n = [0, 0, 0, 1]), n && this.setSource(n) }, _rgbToHsl: function (e, t, n) { e /= 255, t /= 255, n /= 255; var o, i, s, a = r.util.array.max([e, t, n]), u = r.util.array.min([e, t, n]); if (s = (a + u) / 2, a === u) o = i = 0; else { var c = a - u; switch (i = s > .5 ? c / (2 - a - u) : c / (a + u), a) { case e: o = (t - n) / c + (n > t ? 6 : 0); break; case t: o = (n - e) / c + 2; break; case n: o = (e - t) / c + 4 } o /= 6 } return [Math.round(360 * o), Math.round(100 * i), Math.round(100 * s)] }, getSource: function () { return this._source }, setSource: function (e) { this._source = e }, toRgb: function () { var e = this.getSource(); return "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")" }, toRgba: function () { var e = this.getSource(); return "rgba(" + e[0] + "," + e[1] + "," + e[2] + "," + e[3] + ")" }, toHsl: function () { var e = this.getSource(), t = this._rgbToHsl(e[0], e[1], e[2]); return "hsl(" + t[0] + "," + t[1] + "%," + t[2] + "%)" }, toHsla: function () { var e = this.getSource(), t = this._rgbToHsl(e[0], e[1], e[2]); return "hsla(" + t[0] + "," + t[1] + "%," + t[2] + "%," + e[3] + ")" }, toHex: function () { var e, t, n, r = this.getSource(); return e = r[0].toString(16), e = 1 === e.length ? "0" + e : e, t = r[1].toString(16), t = 1 === t.length ? "0" + t : t, n = r[2].toString(16), n = 1 === n.length ? "0" + n : n, e.toUpperCase() + t.toUpperCase() + n.toUpperCase() }, toHexa: function () { var e, t = this.getSource(); return e = 255 * t[3], e = e.toString(16), e = 1 === e.length ? "0" + e : e, this.toHex() + e.toUpperCase() }, getAlpha: function () { return this.getSource()[3] }, setAlpha: function (e) { var t = this.getSource(); return t[3] = e, this.setSource(t), this }, toGrayscale: function () { var e = this.getSource(), t = parseInt((.3 * e[0] + .59 * e[1] + .11 * e[2]).toFixed(0), 10), n = e[3]; return this.setSource([t, t, t, n]), this }, toBlackWhite: function (e) { var t = this.getSource(), n = (.3 * t[0] + .59 * t[1] + .11 * t[2]).toFixed(0), r = t[3]; return e = e || 127, n = Number(n) < Number(e) ? 0 : 255, this.setSource([n, n, n, r]), this }, overlayWith: function (e) { e instanceof t || (e = new t(e)); for (var n = [], r = this.getAlpha(), o = .5, i = this.getSource(), s = e.getSource(), a = 0; 3 > a; a++) n.push(Math.round(i[a] * (1 - o) + s[a] * o)); return n[3] = r, this.setSource(n), this } }, r.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/, r.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/, r.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, r.Color.colorNameMap = { aqua: "#00FFFF", black: "#000000", blue: "#0000FF", fuchsia: "#FF00FF", gray: "#808080", grey: "#808080", green: "#008000", lime: "#00FF00", maroon: "#800000", navy: "#000080", olive: "#808000", orange: "#FFA500", purple: "#800080", red: "#FF0000", silver: "#C0C0C0", teal: "#008080", white: "#FFFFFF", yellow: "#FFFF00" }, r.Color.fromRgb = function (e) { return t.fromSource(t.sourceFromRgb(e)) }, r.Color.sourceFromRgb = function (e) { var n = e.match(t.reRGBa); if (n) { var r = parseInt(n[1], 10) / (/%$/.test(n[1]) ? 100 : 1) * (/%$/.test(n[1]) ? 255 : 1), o = parseInt(n[2], 10) / (/%$/.test(n[2]) ? 100 : 1) * (/%$/.test(n[2]) ? 255 : 1), i = parseInt(n[3], 10) / (/%$/.test(n[3]) ? 100 : 1) * (/%$/.test(n[3]) ? 255 : 1); return [parseInt(r, 10), parseInt(o, 10), parseInt(i, 10), n[4] ? parseFloat(n[4]) : 1] } }, r.Color.fromRgba = t.fromRgb, r.Color.fromHsl = function (e) { return t.fromSource(t.sourceFromHsl(e)) }, r.Color.sourceFromHsl = function (e) { var r = e.match(t.reHSLa); if (r) { var o, i, s, a = (parseFloat(r[1]) % 360 + 360) % 360 / 360, u = parseFloat(r[2]) / (/%$/.test(r[2]) ? 100 : 1), c = parseFloat(r[3]) / (/%$/.test(r[3]) ? 100 : 1); if (0 === u) o = i = s = c; else { var f = .5 >= c ? c * (u + 1) : c + u - c * u, l = 2 * c - f; o = n(l, f, a + 1 / 3), i = n(l, f, a), s = n(l, f, a - 1 / 3) } return [Math.round(255 * o), Math.round(255 * i), Math.round(255 * s), r[4] ? parseFloat(r[4]) : 1] } }, r.Color.fromHsla = t.fromHsl, r.Color.fromHex = function (e) { return t.fromSource(t.sourceFromHex(e)) }, r.Color.sourceFromHex = function (e) { if (e.match(t.reHex)) { var n = e.slice(e.indexOf("#") + 1), r = 3 === n.length || 4 === n.length, o = 8 === n.length || 4 === n.length, i = r ? n.charAt(0) + n.charAt(0) : n.substring(0, 2), s = r ? n.charAt(1) + n.charAt(1) : n.substring(2, 4), a = r ? n.charAt(2) + n.charAt(2) : n.substring(4, 6), u = o ? r ? n.charAt(3) + n.charAt(3) : n.substring(6, 8) : "FF"; return [parseInt(i, 16), parseInt(s, 16), parseInt(a, 16), parseFloat((parseInt(u, 16) / 255).toFixed(2))] } }, void (r.Color.fromSource = function (e) { var n = new t; return n.setSource(e), n })) }("undefined" != typeof exports ? exports : this); !function () { "use strict"; if (fabric.StaticCanvas) return void fabric.warn("fabric.StaticCanvas is already defined."); var e = fabric.util.object.extend, t = fabric.util.getElementOffset, n = fabric.util.removeFromArray, r = fabric.util.toFixed, i = fabric.util.transformPoint, o = fabric.util.invertTransform, s = new Error("Could not initialize `canvas` element"); fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, { initialize: function (e, t) { t || (t = {}), this._initStatic(e, t) }, backgroundColor: "", backgroundImage: null, overlayColor: "", overlayImage: null, includeDefaultValues: !0, stateful: !1, renderOnAddRemove: !0, clipTo: null, controlsAboveOverlay: !1, allowTouchScrolling: !1, imageSmoothingEnabled: !0, viewportTransform: fabric.iMatrix.concat(), backgroundVpt: !0, overlayVpt: !0, onBeforeScaleRotate: function () { }, enableRetinaScaling: !0, vptCoords: {}, skipOffscreen: !1, _initStatic: function (e, t) { var n = fabric.StaticCanvas.prototype.renderAll.bind(this); this._objects = [], this._createLowerCanvas(e), this._initOptions(t), this._setImageSmoothing(), this.interactive || this._initRetinaScaling(), t.overlayImage && this.setOverlayImage(t.overlayImage, n), t.backgroundImage && this.setBackgroundImage(t.backgroundImage, n), t.backgroundColor && this.setBackgroundColor(t.backgroundColor, n), t.overlayColor && this.setOverlayColor(t.overlayColor, n), this.calcOffset() }, _isRetinaScaling: function () { return 1 !== fabric.devicePixelRatio && this.enableRetinaScaling }, getRetinaScaling: function () { return this._isRetinaScaling() ? fabric.devicePixelRatio : 1 }, _initRetinaScaling: function () { this._isRetinaScaling() && (this.lowerCanvasEl.setAttribute("width", this.width * fabric.devicePixelRatio), this.lowerCanvasEl.setAttribute("height", this.height * fabric.devicePixelRatio), this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio)) }, calcOffset: function () { return this._offset = t(this.lowerCanvasEl), this }, setOverlayImage: function (e, t, n) { return this.__setBgOverlayImage("overlayImage", e, t, n) }, setBackgroundImage: function (e, t, n) { return this.__setBgOverlayImage("backgroundImage", e, t, n) }, setOverlayColor: function (e, t) { return this.__setBgOverlayColor("overlayColor", e, t) }, setBackgroundColor: function (e, t) { return this.__setBgOverlayColor("backgroundColor", e, t) }, _setImageSmoothing: function () { var e = this.getContext(); e.imageSmoothingEnabled = e.imageSmoothingEnabled || e.webkitImageSmoothingEnabled || e.mozImageSmoothingEnabled || e.msImageSmoothingEnabled || e.oImageSmoothingEnabled, e.imageSmoothingEnabled = this.imageSmoothingEnabled }, __setBgOverlayImage: function (e, t, n, r) { return "string" == typeof t ? fabric.util.loadImage(t, function (t) { t && (this[e] = new fabric.Image(t, r)), n && n(t) }, this, r && r.crossOrigin) : (r && t.setOptions(r), this[e] = t, n && n(t)), this }, __setBgOverlayColor: function (e, t, n) { return this[e] = t, this._initGradient(t, e), this._initPattern(t, e, n), this }, _createCanvasElement: function (e) { var t = fabric.util.createCanvasElement(e); if (t.style || (t.style = {}), !t) throw s; if ("undefined" == typeof t.getContext) throw s; return t }, _initOptions: function (e) { this._setOptions(e), this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0, this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0, this.lowerCanvasEl.style && (this.lowerCanvasEl.width = this.width, this.lowerCanvasEl.height = this.height, this.lowerCanvasEl.style.width = this.width + "px", this.lowerCanvasEl.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice()) }, _createLowerCanvas: function (e) { this.lowerCanvasEl = fabric.util.getById(e) || this._createCanvasElement(e), fabric.util.addClass(this.lowerCanvasEl, "lower-canvas"), this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d") }, getWidth: function () { return this.width }, getHeight: function () { return this.height }, setWidth: function (e, t) { return this.setDimensions({ width: e }, t) }, setHeight: function (e, t) { return this.setDimensions({ height: e }, t) }, setDimensions: function (e, t) { var n; t = t || {}; for (var r in e) n = e[r], t.cssOnly || (this._setBackstoreDimension(r, e[r]), n += "px"), t.backstoreOnly || this._setCssDimension(r, n); return this._initRetinaScaling(), this._setImageSmoothing(), this.calcOffset(), t.cssOnly || this.renderAll(), this }, _setBackstoreDimension: function (e, t) { return this.lowerCanvasEl[e] = t, this.upperCanvasEl && (this.upperCanvasEl[e] = t), this.cacheCanvasEl && (this.cacheCanvasEl[e] = t), this[e] = t, this }, _setCssDimension: function (e, t) { return this.lowerCanvasEl.style[e] = t, this.upperCanvasEl && (this.upperCanvasEl.style[e] = t), this.wrapperEl && (this.wrapperEl.style[e] = t), this }, getZoom: function () { return this.viewportTransform[0] }, setViewportTransform: function (e) { var t, n = this._activeGroup, r = !1, i = !0; this.viewportTransform = e; for (var o = 0, s = this._objects.length; s > o; o++) t = this._objects[o], t.group || t.setCoords(r, i); return n && n.setCoords(r, i), this.calcViewportBoundaries(), this.renderAll(), this }, zoomToPoint: function (e, t) { var n = e, r = this.viewportTransform.slice(0); e = i(e, o(this.viewportTransform)), r[0] = t, r[3] = t; var s = i(e, r); return r[4] += n.x - s.x, r[5] += n.y - s.y, this.setViewportTransform(r) }, setZoom: function (e) { return this.zoomToPoint(new fabric.Point(0, 0), e), this }, absolutePan: function (e) { var t = this.viewportTransform.slice(0); return t[4] = -e.x, t[5] = -e.y, this.setViewportTransform(t) }, relativePan: function (e) { return this.absolutePan(new fabric.Point(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5])) }, getElement: function () { return this.lowerCanvasEl }, _onObjectAdded: function (e) { this.stateful && e.setupState(), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added") }, _onObjectRemoved: function (e) { this.fire("object:removed", { target: e }), e.fire("removed"), delete e.canvas }, clearContext: function (e) { return e.clearRect(0, 0, this.width, this.height), this }, getContext: function () { return this.contextContainer }, clear: function () { return this._objects.length = 0, this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderAll(), this }, renderAll: function () { var e = this.contextContainer; return this.renderCanvas(e, this._objects), this }, calcViewportBoundaries: function () { var e = {}, t = this.getWidth(), n = this.getHeight(), r = o(this.viewportTransform); return e.tl = i({ x: 0, y: 0 }, r), e.br = i({ x: t, y: n }, r), e.tr = new fabric.Point(e.br.x, e.tl.y), e.bl = new fabric.Point(e.tl.x, e.br.y), this.vptCoords = e, e }, renderCanvas: function (e, t) { this.calcViewportBoundaries(), this.clearContext(e), this.fire("before:render"), this.clipTo && fabric.util.clipContext(this, e), this._renderBackground(e), e.save(), e.transform.apply(e, this.viewportTransform), this._renderObjects(e, t), e.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(e), this.clipTo && e.restore(), this._renderOverlay(e), this.controlsAboveOverlay && this.interactive && this.drawControls(e), this.fire("after:render") }, _renderObjects: function (e, t) { for (var n = 0, r = t.length; r > n; ++n) t[n] && t[n].render(e) }, _renderBackgroundOrOverlay: function (e, t) { var n = this[t + "Color"]; n && (e.fillStyle = n.toLive ? n.toLive(e, this) : n, e.fillRect(n.offsetX || 0, n.offsetY || 0, this.width, this.height)), n = this[t + "Image"], n && (this[t + "Vpt"] && (e.save(), e.transform.apply(e, this.viewportTransform)), n.render(e), this[t + "Vpt"] && e.restore()) }, _renderBackground: function (e) { this._renderBackgroundOrOverlay(e, "background") }, _renderOverlay: function (e) { this._renderBackgroundOrOverlay(e, "overlay") }, getCenter: function () { return { top: this.getHeight() / 2, left: this.getWidth() / 2 } }, centerObjectH: function (e) { return this._centerObject(e, new fabric.Point(this.getCenter().left, e.getCenterPoint().y)) }, centerObjectV: function (e) { return this._centerObject(e, new fabric.Point(e.getCenterPoint().x, this.getCenter().top)) }, centerObject: function (e) { var t = this.getCenter(); return this._centerObject(e, new fabric.Point(t.left, t.top)) }, viewportCenterObject: function (e) { var t = this.getVpCenter(); return this._centerObject(e, t) }, viewportCenterObjectH: function (e) { var t = this.getVpCenter(); return this._centerObject(e, new fabric.Point(t.x, e.getCenterPoint().y)), this }, viewportCenterObjectV: function (e) { var t = this.getVpCenter(); return this._centerObject(e, new fabric.Point(e.getCenterPoint().x, t.y)) }, getVpCenter: function () { var e = this.getCenter(), t = o(this.viewportTransform); return i({ x: e.left, y: e.top }, t) }, _centerObject: function (e, t) { return e.setPositionByOrigin(t, "center", "center"), this.renderAll(), this }, toDatalessJSON: function (e) { return this.toDatalessObject(e) }, toObject: function (e) { return this._toObjectMethod("toObject", e) }, toDatalessObject: function (e) { return this._toObjectMethod("toDatalessObject", e) }, _toObjectMethod: function (t, n) { var r = { objects: this._toObjects(t, n) }; return e(r, this.__serializeBgOverlay(t, n)), fabric.util.populateWithProperties(this, r, n), r }, _toObjects: function (e, t) { return this.getObjects().filter(function (e) { return !e.excludeFromExport }).map(function (n) { return this._toObject(n, e, t) }, this) }, _toObject: function (e, t, n) { var r; this.includeDefaultValues || (r = e.includeDefaultValues, e.includeDefaultValues = !1); var i = e[t](n); return this.includeDefaultValues || (e.includeDefaultValues = r), i }, __serializeBgOverlay: function (e, t) { var n = {}; return this.backgroundColor && (n.background = this.backgroundColor.toObject ? this.backgroundColor.toObject(t) : this.backgroundColor), this.overlayColor && (n.overlay = this.overlayColor.toObject ? this.overlayColor.toObject(t) : this.overlayColor), this.backgroundImage && (n.backgroundImage = this._toObject(this.backgroundImage, e, t)), this.overlayImage && (n.overlayImage = this._toObject(this.overlayImage, e, t)), n }, svgViewportTransformation: !0, toSVG: function (e, t) { e || (e = {}); var n = []; return this._setSVGPreamble(n, e), this._setSVGHeader(n, e), this._setSVGBgOverlayColor(n, "backgroundColor"), this._setSVGBgOverlayImage(n, "backgroundImage", t), this._setSVGObjects(n, t), this._setSVGBgOverlayColor(n, "overlayColor"), this._setSVGBgOverlayImage(n, "overlayImage", t), n.push("</svg>"), n.join("") }, _setSVGPreamble: function (e, t) { t.suppressPreamble || e.push('<?xml version="1.0" encoding="', t.encoding || "UTF-8", '" standalone="no" ?>\n', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n') }, _setSVGHeader: function (e, t) { var n, i = t.width || this.width, o = t.height || this.height, s = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', a = fabric.Object.NUM_FRACTION_DIGITS; t.viewBox ? s = 'viewBox="' + t.viewBox.x + " " + t.viewBox.y + " " + t.viewBox.width + " " + t.viewBox.height + '" ' : this.svgViewportTransformation && (n = this.viewportTransform, s = 'viewBox="' + r(-n[4] / n[0], a) + " " + r(-n[5] / n[3], a) + " " + r(this.width / n[0], a) + " " + r(this.height / n[3], a) + '" '), e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', i, '" ', 'height="', o, '" ', s, 'xml:space="preserve">\n', "<desc>Created with Fabric.js ", fabric.version, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), "</defs>\n") }, createSVGRefElementsMarkup: function () { var e = this, t = ["backgroundColor", "overlayColor"].map(function (t) { var n = e[t]; return n && n.toLive ? n.toSVG(e, !1) : void 0 }); return t.join("") }, createSVGFontFacesMarkup: function () { for (var e, t, n, r, i, o, s, a = "", c = {}, u = fabric.fontPaths, l = this.getObjects(), f = 0, h = l.length; h > f; f++) if (e = l[f], t = e.fontFamily, -1 !== e.type.indexOf("text") && !c[t] && u[t] && (c[t] = !0, e.styles)) { n = e.styles; for (i in n) { r = n[i]; for (s in r) o = r[s], t = o.fontFamily, !c[t] && u[t] && (c[t] = !0) } } for (var v in c) a += ["		@font-face {\n", "			font-family: '", v, "';\n", "			src: url('", u[v], "');\n", "		}\n"].join(""); return a && (a = ['	<style type="text/css">', "<![CDATA[\n", a, "]]>", "</style>\n"].join("")), a }, _setSVGObjects: function (e, t) { for (var n, r = 0, i = this.getObjects(), o = i.length; o > r; r++) n = i[r], n.excludeFromExport || this._setSVGObject(e, n, t) }, _setSVGObject: function (e, t, n) { e.push(t.toSVG(n)) }, _setSVGBgOverlayImage: function (e, t, n) { this[t] && this[t].toSVG && e.push(this[t].toSVG(n)) }, _setSVGBgOverlayColor: function (e, t) { var n = this[t]; if (n) if (n.toLive) { var r = n.repeat; e.push('<rect transform="translate(', this.width / 2, ",", this.height / 2, ')"', ' x="', n.offsetX - this.width / 2, '" y="', n.offsetY - this.height / 2, '" ', 'width="', "repeat-y" === r || "no-repeat" === r ? n.source.width : this.width, '" height="', "repeat-x" === r || "no-repeat" === r ? n.source.height : this.height, '" fill="url(#SVGID_' + n.id + ')"', "></rect>\n") } else e.push('<rect x="0" y="0" ', 'width="', this.width, '" height="', this.height, '" fill="', this[t], '"', "></rect>\n") }, sendToBack: function (e) { if (!e) return this; var t, r, i, o = this._activeGroup; if (e === o) for (i = o._objects, t = i.length; t--;) r = i[t], n(this._objects, r), this._objects.unshift(r); else n(this._objects, e), this._objects.unshift(e); return this.renderAll && this.renderAll() }, bringToFront: function (e) { if (!e) return this; var t, r, i, o = this._activeGroup; if (e === o) for (i = o._objects, t = 0; t < i.length; t++) r = i[t], n(this._objects, r), this._objects.push(r); else n(this._objects, e), this._objects.push(e); return this.renderAll && this.renderAll() }, sendBackwards: function (e, t) { if (!e) return this; var r, i, o, s, a, c = this._activeGroup; if (e === c) for (a = c._objects, r = 0; r < a.length; r++) i = a[r], o = this._objects.indexOf(i), 0 !== o && (s = o - 1, n(this._objects, i), this._objects.splice(s, 0, i)); else o = this._objects.indexOf(e), 0 !== o && (s = this._findNewLowerIndex(e, o, t), n(this._objects, e), this._objects.splice(s, 0, e)); return this.renderAll && this.renderAll(), this }, _findNewLowerIndex: function (e, t, n) { var r; if (n) { r = t; for (var i = t - 1; i >= 0; --i) { var o = e.intersectsWithObject(this._objects[i]) || e.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(e); if (o) { r = i; break } } } else r = t - 1; return r }, bringForward: function (e, t) { if (!e) return this; var r, i, o, s, a, c = this._activeGroup; if (e === c) for (a = c._objects, r = a.length; r--;) i = a[r], o = this._objects.indexOf(i), o !== this._objects.length - 1 && (s = o + 1, n(this._objects, i), this._objects.splice(s, 0, i)); else o = this._objects.indexOf(e), o !== this._objects.length - 1 && (s = this._findNewUpperIndex(e, o, t), n(this._objects, e), this._objects.splice(s, 0, e)); return this.renderAll && this.renderAll(), this }, _findNewUpperIndex: function (e, t, n) { var r; if (n) { r = t; for (var i = t + 1; i < this._objects.length; ++i) { var o = e.intersectsWithObject(this._objects[i]) || e.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(e); if (o) { r = i; break } } } else r = t + 1; return r }, moveTo: function (e, t) { return n(this._objects, e), this._objects.splice(t, 0, e), this.renderAll && this.renderAll() }, dispose: function () { return this.clear(), this }, toString: function () { return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this.getObjects().length + " }>" } }), e(fabric.StaticCanvas.prototype, fabric.Observable), e(fabric.StaticCanvas.prototype, fabric.Collection), e(fabric.StaticCanvas.prototype, fabric.DataURLExporter), e(fabric.StaticCanvas, { EMPTY_JSON: '{"objects": [], "background": "white"}', supports: function (e) { var t = fabric.util.createCanvasElement(); if (!t || !t.getContext) return null; var n = t.getContext("2d"); if (!n) return null; switch (e) { case "getImageData": return "undefined" != typeof n.getImageData; case "setLineDash": return "undefined" != typeof n.setLineDash; case "toDataURL": return "undefined" != typeof t.toDataURL; case "toDataURLWithQuality": try { return t.toDataURL("image/jpeg", 0), !0 } catch (r) { } return !1; default: return null } } }), fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject }(); !function () { var e = fabric.util.getPointer, t = fabric.util.degreesToRadians, n = fabric.util.radiansToDegrees, r = Math.atan2, i = Math.abs, o = fabric.StaticCanvas.supports("setLineDash"), s = .5; fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, { initialize: function (e, t) { t || (t = {}), this._initStatic(e, t), this._initInteractive(), this._createCacheCanvas() }, uniScaleTransform: !1, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", interactive: !0, selection: !0, selectionKey: "shiftKey", altSelectionKey: null, selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", rotationCursor: "crosshair", containerClass: "canvas-container", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, isDrawingMode: !1, preserveObjectStacking: !1, snapAngle: 0, snapThreshold: null, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, _initInteractive: function () { this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this), this.calcOffset() }, _chooseObjectsToRender: function () { var e, t = this.getActiveGroup(), n = this.getActiveObject(), r = [], i = []; if (!t && !n || this.preserveObjectStacking) r = this._objects; else { for (var o = 0, s = this._objects.length; s > o; o++) e = this._objects[o], t && t.contains(e) || e === n ? i.push(e) : r.push(e); t && (t._set("_objects", i), r.push(t)), n && r.push(n) } return r }, renderAll: function () { !this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1); var e = this.contextContainer; return this.renderCanvas(e, this._chooseObjectsToRender()), this }, renderTop: function () { var e = this.contextTop; return this.clearContext(e), this.selection && this._groupSelector && this._drawSelection(e), this.fire("after:render"), this.contextTopDirty = !0, this }, _resetCurrentTransform: function () { var e = this._currentTransform; e.target.set({ scaleX: e.original.scaleX, scaleY: e.original.scaleY, skewX: e.original.skewX, skewY: e.original.skewY, left: e.original.left, top: e.original.top }), this._shouldCenterTransform(e.target) ? "rotate" === e.action ? this._setOriginToCenter(e.target) : ("center" !== e.originX && (e.mouseXSign = "right" === e.originX ? -1 : 1), "center" !== e.originY && (e.mouseYSign = "bottom" === e.originY ? -1 : 1), e.originX = "center", e.originY = "center") : (e.originX = e.original.originX, e.originY = e.original.originY) }, containsPoint: function (e, t, n) { var r, i = !0, o = n || this.getPointer(e, i); return r = t.group && t.group === this.getActiveGroup() ? this._normalizePointer(t.group, o) : { x: o.x, y: o.y }, t.containsPoint(r) || t._findTargetCorner(o) }, _normalizePointer: function (e, t) { var n = e.calcTransformMatrix(), r = fabric.util.invertTransform(n), i = this.restorePointerVpt(t); return fabric.util.transformPoint(i, r) }, isTargetTransparent: function (e, t, n) { var r = e.hasBorders, i = e.transparentCorners, o = this.contextCache, s = e.selectionBackgroundColor; e.hasBorders = e.transparentCorners = !1, e.selectionBackgroundColor = "", o.save(), o.transform.apply(o, this.viewportTransform), e.render(o), o.restore(), e.active && e._renderControls(o), e.hasBorders = r, e.transparentCorners = i, e.selectionBackgroundColor = s; var a = fabric.util.isTransparent(o, t, n, this.targetFindTolerance); return this.clearContext(o), a }, _shouldClearSelection: function (e, t) { var n = this.getActiveGroup(), r = this.getActiveObject(); return !t || t && n && !n.contains(t) && n !== t && !e[this.selectionKey] || t && !t.evented || t && !t.selectable && r && r !== t }, _shouldCenterTransform: function (e) { if (e) { var t, n = this._currentTransform; return "scale" === n.action || "scaleX" === n.action || "scaleY" === n.action ? t = this.centeredScaling || e.centeredScaling : "rotate" === n.action && (t = this.centeredRotation || e.centeredRotation), t ? !n.altKey : n.altKey } }, _getOriginFromCorner: function (e, t) { var n = { x: e.originX, y: e.originY }; return "ml" === t || "tl" === t || "bl" === t ? n.x = "right" : ("mr" === t || "tr" === t || "br" === t) && (n.x = "left"), "tl" === t || "mt" === t || "tr" === t ? n.y = "bottom" : ("bl" === t || "mb" === t || "br" === t) && (n.y = "top"), n }, _getActionFromCorner: function (e, t, n) { if (!t) return "drag"; switch (t) { case "mtr": return "rotate"; case "ml": case "mr": return n[this.altActionKey] ? "skewY" : "scaleX"; case "mt": case "mb": return n[this.altActionKey] ? "skewX" : "scaleY"; default: return "scale" } }, _setupCurrentTransform: function (e, n) { if (n) { var r = this.getPointer(e), i = n._findTargetCorner(this.getPointer(e, !0)), o = this._getActionFromCorner(n, i, e), s = this._getOriginFromCorner(n, i); this._currentTransform = { target: n, action: o, corner: i, scaleX: n.scaleX, scaleY: n.scaleY, skewX: n.skewX, skewY: n.skewY, offsetX: r.x - n.left, offsetY: r.y - n.top, originX: s.x, originY: s.y, ex: r.x, ey: r.y, lastX: r.x, lastY: r.y, left: n.left, top: n.top, theta: t(n.angle), width: n.width * n.scaleX, mouseXSign: 1, mouseYSign: 1, shiftKey: e.shiftKey, altKey: e[this.centeredKey] }, this._currentTransform.original = { left: n.left, top: n.top, scaleX: n.scaleX, scaleY: n.scaleY, skewX: n.skewX, skewY: n.skewY, originX: s.x, originY: s.y }, this._resetCurrentTransform() } }, _translateObject: function (e, t) { var n = this._currentTransform, r = n.target, i = e - n.offsetX, o = t - n.offsetY, s = !r.get("lockMovementX") && r.left !== i, a = !r.get("lockMovementY") && r.top !== o; return s && r.set("left", i), a && r.set("top", o), s || a }, _changeSkewTransformOrigin: function (e, t, n) { var r = "originX", i = { 0: "center" }, o = t.target.skewX, s = "left", a = "right", c = "mt" === t.corner || "ml" === t.corner ? 1 : -1, u = 1; e = e > 0 ? 1 : -1, "y" === n && (o = t.target.skewY, s = "top", a = "bottom", r = "originY"), i[-1] = s, i[1] = a, t.target.flipX && (u *= -1), t.target.flipY && (u *= -1), 0 === o ? (t.skewSign = -c * e * u, t[r] = i[-e]) : (o = o > 0 ? 1 : -1, t.skewSign = o, t[r] = i[o * c * u]) }, _skewObject: function (e, t, n) { var r = this._currentTransform, i = r.target, o = !1, s = i.get("lockSkewingX"), a = i.get("lockSkewingY"); if (s && "x" === n || a && "y" === n) return !1; var c, u, l = i.getCenterPoint(), f = i.toLocalPoint(new fabric.Point(e, t), "center", "center")[n], h = i.toLocalPoint(new fabric.Point(r.lastX, r.lastY), "center", "center")[n], v = i._getTransformedDimensions(); return this._changeSkewTransformOrigin(f - h, r, n), c = i.toLocalPoint(new fabric.Point(e, t), r.originX, r.originY)[n], u = i.translateToOriginPoint(l, r.originX, r.originY), o = this._setObjectSkew(c, r, n, v), r.lastX = e, r.lastY = t, i.setPositionByOrigin(u, r.originX, r.originY), o }, _setObjectSkew: function (e, t, n, r) { var i, o, s, a, c, u, l, f, h, v = t.target, d = !1, p = t.skewSign; return "x" === n ? (a = "y", c = "Y", u = "X", f = 0, h = v.skewY) : (a = "x", c = "X", u = "Y", f = v.skewX, h = 0), s = v._getTransformedDimensions(f, h), l = 2 * Math.abs(e) - s[n], 2 >= l ? i = 0 : (i = p * Math.atan(l / v["scale" + u] / (s[a] / v["scale" + c])), i = fabric.util.radiansToDegrees(i)), d = v["skew" + u] !== i, v.set("skew" + u, i), 0 !== v["skew" + c] && (o = v._getTransformedDimensions(), i = r[a] / o[a] * v["scale" + c], v.set("scale" + c, i)), d }, _scaleObject: function (e, t, n) { var r = this._currentTransform, i = r.target, o = i.get("lockScalingX"), s = i.get("lockScalingY"), a = i.get("lockScalingFlip"); if (o && s) return !1; var c = i.translateToOriginPoint(i.getCenterPoint(), r.originX, r.originY), u = i.toLocalPoint(new fabric.Point(e, t), r.originX, r.originY), l = i._getTransformedDimensions(), f = !1; return this._setLocalMouse(u, r), f = this._setObjectScale(u, r, o, s, n, a, l), i.setPositionByOrigin(c, r.originX, r.originY), f }, _setObjectScale: function (e, t, n, r, i, o, s) { var a, c, u, l, f = t.target, h = !1, v = !1, d = !1; return u = e.x * f.scaleX / s.x, l = e.y * f.scaleY / s.y, a = f.scaleX !== u, c = f.scaleY !== l, o && 0 >= u && u < f.scaleX && (h = !0), o && 0 >= l && l < f.scaleY && (v = !0), "equally" !== i || n || r ? i ? "x" !== i || f.get("lockUniScaling") ? "y" !== i || f.get("lockUniScaling") || v || r || f.set("scaleY", l) && (d = d || c) : h || n || f.set("scaleX", u) && (d = d || a) : (h || n || f.set("scaleX", u) && (d = d || a), v || r || f.set("scaleY", l) && (d = d || c)) : h || v || (d = this._scaleObjectEqually(e, f, t, s)), t.newScaleX = u, t.newScaleY = l, h || v || this._flipObject(t, i), d }, _scaleObjectEqually: function (e, t, n, r) { var i, o = e.y + e.x, s = r.y * n.original.scaleY / t.scaleY + r.x * n.original.scaleX / t.scaleX; return n.newScaleX = n.original.scaleX * o / s, n.newScaleY = n.original.scaleY * o / s, i = n.newScaleX !== t.scaleX || n.newScaleY !== t.scaleY, t.set("scaleX", n.newScaleX), t.set("scaleY", n.newScaleY), i }, _flipObject: function (e, t) { e.newScaleX < 0 && "y" !== t && ("left" === e.originX ? e.originX = "right" : "right" === e.originX && (e.originX = "left")), e.newScaleY < 0 && "x" !== t && ("top" === e.originY ? e.originY = "bottom" : "bottom" === e.originY && (e.originY = "top")) }, _setLocalMouse: function (e, t) { var n = t.target, r = this.getZoom(), o = n.padding / r; "right" === t.originX ? e.x *= -1 : "center" === t.originX && (e.x *= 2 * t.mouseXSign, e.x < 0 && (t.mouseXSign = -t.mouseXSign)), "bottom" === t.originY ? e.y *= -1 : "center" === t.originY && (e.y *= 2 * t.mouseYSign, e.y < 0 && (t.mouseYSign = -t.mouseYSign)), i(e.x) > o ? e.x < 0 ? e.x += o : e.x -= o : e.x = 0, i(e.y) > o ? e.y < 0 ? e.y += o : e.y -= o : e.y = 0 }, _rotateObject: function (e, t) { var i = this._currentTransform; if (i.target.get("lockRotation")) return !1; var o = r(i.ey - i.top, i.ex - i.left), s = r(t - i.top, e - i.left), a = n(s - o + i.theta), c = !0; if (0 > a && (a = 360 + a), a %= 360, i.target.snapAngle > 0) { var u = i.target.snapAngle, l = i.target.snapThreshold || u, f = Math.ceil(a / u) * u, h = Math.floor(a / u) * u; Math.abs(a - h) < l ? a = h : Math.abs(a - f) < l && (a = f), i.target.angle === a && (c = !1) } return i.target.angle = a, c }, setCursor: function (e) { this.upperCanvasEl.style.cursor = e }, _resetObjectTransform: function (e) { e.scaleX = 1, e.scaleY = 1, e.skewX = 0, e.skewY = 0, e.setAngle(0) }, _drawSelection: function (e) { var t = this._groupSelector, n = t.left, r = t.top, a = i(n), c = i(r); if (this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(t.ex - (n > 0 ? 0 : -n), t.ey - (r > 0 ? 0 : -r), a, c)), this.selectionLineWidth && this.selectionBorderColor) if (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, this.selectionDashArray.length > 1 && !o) { var u = t.ex + s - (n > 0 ? 0 : a), l = t.ey + s - (r > 0 ? 0 : c); e.beginPath(), fabric.util.drawDashedLine(e, u, l, u + a, l, this.selectionDashArray), fabric.util.drawDashedLine(e, u, l + c - 1, u + a, l + c - 1, this.selectionDashArray), fabric.util.drawDashedLine(e, u, l, u, l + c, this.selectionDashArray), fabric.util.drawDashedLine(e, u + a - 1, l, u + a - 1, l + c, this.selectionDashArray), e.closePath(), e.stroke() } else fabric.Object.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(t.ex + s - (n > 0 ? 0 : a), t.ey + s - (r > 0 ? 0 : c), a, c) }, findTarget: function (e, t) { if (!this.skipTargetFind) { var n, r = !0, i = this.getPointer(e, r), o = this.getActiveGroup(), s = this.getActiveObject(); if (o && !t && o === this._searchPossibleTargets([o], i)) return this._fireOverOutEvents(o, e), o; if (s && s._findTargetCorner(i)) return this._fireOverOutEvents(s, e), s; if (s && s === this._searchPossibleTargets([s], i)) { if (!this.preserveObjectStacking) return this._fireOverOutEvents(s, e), s; n = s } this.targets = []; var a = this._searchPossibleTargets(this._objects, i); return e[this.altSelectionKey] && a && n && a !== n && (a = n), this._fireOverOutEvents(a, e), a } }, _fireOverOutEvents: function (e, t) { e ? this._hoveredTarget !== e && (this._hoveredTarget && (this.fire("mouse:out", { target: this._hoveredTarget, e: t }), this._hoveredTarget.fire("mouseout")), this.fire("mouse:over", { target: e, e: t }), e.fire("mouseover"), this._hoveredTarget = e) : this._hoveredTarget && (this.fire("mouse:out", { target: this._hoveredTarget, e: t }), this._hoveredTarget.fire("mouseout"), this._hoveredTarget = null) }, _checkTarget: function (e, t) { if (t && t.visible && t.evented && this.containsPoint(null, t, e)) { if (!this.perPixelTargetFind && !t.perPixelTargetFind || t.isEditing) return !0; var n = this.isTargetTransparent(t, e.x, e.y); if (!n) return !0 } }, _searchPossibleTargets: function (e, t) { for (var n, r, i, o = e.length; o--;) if (this._checkTarget(t, e[o])) { n = e[o], "group" === n.type && n.subTargetCheck && (r = this._normalizePointer(n, t), i = this._searchPossibleTargets(n._objects, r), i && this.targets.push(i)); break } return n }, restorePointerVpt: function (e) { return fabric.util.transformPoint(e, fabric.util.invertTransform(this.viewportTransform)) }, getPointer: function (t, n, r) { r || (r = this.upperCanvasEl); var i, o = e(t), s = r.getBoundingClientRect(), a = s.width || 0, c = s.height || 0; return a && c || ("top" in s && "bottom" in s && (c = Math.abs(s.top - s.bottom)), "right" in s && "left" in s && (a = Math.abs(s.right - s.left))), this.calcOffset(), o.x = o.x - this._offset.left, o.y = o.y - this._offset.top, n || (o = this.restorePointerVpt(o)), i = 0 === a || 0 === c ? { width: 1, height: 1 } : { width: r.width / a, height: r.height / c }, { x: o.x * i.width, y: o.y * i.height } }, _createUpperCanvas: function () { var e = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""); this.upperCanvasEl = this._createCanvasElement(), fabric.util.addClass(this.upperCanvasEl, "upper-canvas " + e), this.wrapperEl.appendChild(this.upperCanvasEl), this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl), this._applyCanvasStyle(this.upperCanvasEl), this.contextTop = this.upperCanvasEl.getContext("2d") }, _createCacheCanvas: function () { this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d") }, _initWrapperElement: function () { this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, "div", { "class": this.containerClass }), fabric.util.setStyle(this.wrapperEl, { width: this.getWidth() + "px", height: this.getHeight() + "px", position: "relative" }), fabric.util.makeElementUnselectable(this.wrapperEl) }, _applyCanvasStyle: function (e) { var t = this.getWidth() || e.width, n = this.getHeight() || e.height; fabric.util.setStyle(e, { position: "absolute", width: t + "px", height: n + "px", left: 0, top: 0, "touch-action": "none" }), e.width = t, e.height = n, fabric.util.makeElementUnselectable(e) }, _copyCanvasStyle: function (e, t) { t.style.cssText = e.style.cssText }, getSelectionContext: function () { return this.contextTop }, getSelectionElement: function () { return this.upperCanvasEl }, _setActiveObject: function (e) { var t = this._activeObject; t && (t.set("active", !1), e !== t && t.onDeselect && "function" == typeof t.onDeselect && t.onDeselect()), this._activeObject = e, e.set("active", !0) }, setActiveObject: function (e, t) { var n = this.getActiveObject(); return n && n !== e && n.fire("deselected", { e: t }), this._setActiveObject(e), this.renderAll(), this.fire("object:selected", { target: e, e: t }), e.fire("selected", { e: t }), this }, getActiveObject: function () { return this._activeObject }, _onObjectRemoved: function (e) { this.getActiveObject() === e && (this.fire("before:selection:cleared", { target: e }), this._discardActiveObject(), this.fire("selection:cleared", { target: e }), e.fire("deselected")), this._hoveredTarget === e && (this._hoveredTarget = null), this.callSuper("_onObjectRemoved", e) }, _discardActiveObject: function () { var e = this._activeObject; e && (e.set("active", !1), e.onDeselect && "function" == typeof e.onDeselect && e.onDeselect()), this._activeObject = null }, discardActiveObject: function (e) { var t = this._activeObject; return t && (this.fire("before:selection:cleared", { target: t, e: e }), this._discardActiveObject(), this.fire("selection:cleared", { e: e }), t.fire("deselected", { e: e })), this }, _setActiveGroup: function (e) { this._activeGroup = e, e && e.set("active", !0) }, setActiveGroup: function (e, t) { return this._setActiveGroup(e), e && (this.fire("object:selected", { target: e, e: t }), e.fire("selected", { e: t })), this }, getActiveGroup: function () { return this._activeGroup }, _discardActiveGroup: function () { var e = this.getActiveGroup(); e && e.destroy(), this.setActiveGroup(null) }, discardActiveGroup: function (e) { var t = this.getActiveGroup(); return t && (this.fire("before:selection:cleared", { e: e, target: t }), this._discardActiveGroup(), this.fire("selection:cleared", { e: e })), this }, deactivateAll: function () { for (var e, t = this.getObjects(), n = 0, r = t.length; r > n; n++) e = t[n], e && e.set("active", !1); return this._discardActiveGroup(), this._discardActiveObject(), this }, deactivateAllWithDispatch: function (e) { return this.discardActiveGroup(e), this.discardActiveObject(e), this.deactivateAll(), this }, dispose: function () { this.callSuper("dispose"); var e = this.wrapperEl; return this.removeListeners(), e.removeChild(this.upperCanvasEl), e.removeChild(this.lowerCanvasEl), delete this.upperCanvasEl, e.parentNode && e.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, this }, clear: function () { return this.discardActiveGroup(), this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear") }, drawControls: function (e) { var t = this.getActiveGroup(); t ? t._renderControls(e) : this._drawObjectsControls(e) }, _drawObjectsControls: function (e) { for (var t = 0, n = this._objects.length; n > t; ++t) this._objects[t] && this._objects[t].active && this._objects[t]._renderControls(e) }, _toObject: function (e, t, n) { var r = this._realizeGroupTransformOnObject(e), i = this.callSuper("_toObject", e, t, n); return this._unwindGroupTransformOnObject(e, r), i }, _realizeGroupTransformOnObject: function (e) { var t = ["angle", "flipX", "flipY", "height", "left", "scaleX", "scaleY", "top", "width"]; if (e.group && e.group === this.getActiveGroup()) { var n = {}; return t.forEach(function (t) { n[t] = e[t] }), this.getActiveGroup().realizeTransform(e), n } return null }, _unwindGroupTransformOnObject: function (e, t) { t && e.set(t) }, _setSVGObject: function (e, t, n) { var r; r = this._realizeGroupTransformOnObject(t), this.callSuper("_setSVGObject", e, t, n), this._unwindGroupTransformOnObject(t, r) } }); for (var a in fabric.StaticCanvas) "prototype" !== a && (fabric.Canvas[a] = fabric.StaticCanvas[a]); fabric.isTouchSupported && (fabric.Canvas.prototype._setCursorFromEvent = function () { }), fabric.Element = fabric.Canvas }(); !function () { var e = { mt: 0, tr: 1, mr: 2, br: 3, mb: 4, bl: 5, ml: 6, tl: 7 }, t = fabric.util.addListener, n = fabric.util.removeListener; fabric.util.object.extend(fabric.Canvas.prototype, { cursorMap: ["n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize"], _initEventListeners: function () { this._bindEvents(), t(fabric.window, "resize", this._onResize), t(this.upperCanvasEl, "mousedown", this._onMouseDown), t(this.upperCanvasEl, "mousemove", this._onMouseMove), t(this.upperCanvasEl, "mouseout", this._onMouseOut), t(this.upperCanvasEl, "mouseenter", this._onMouseEnter), t(this.upperCanvasEl, "wheel", this._onMouseWheel), t(this.upperCanvasEl, "contextmenu", this._onContextMenu), t(this.upperCanvasEl, "touchstart", this._onMouseDown, { passive: !1 }), t(this.upperCanvasEl, "touchmove", this._onMouseMove, { passive: !1 }), "undefined" != typeof eventjs && "add" in eventjs && (eventjs.add(this.upperCanvasEl, "gesture", this._onGesture), eventjs.add(this.upperCanvasEl, "drag", this._onDrag), eventjs.add(this.upperCanvasEl, "orientation", this._onOrientationChange), eventjs.add(this.upperCanvasEl, "shake", this._onShake), eventjs.add(this.upperCanvasEl, "longpress", this._onLongPress)) }, _bindEvents: function () { this._onMouseDown = this._onMouseDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this) }, removeListeners: function () { n(fabric.window, "resize", this._onResize), n(this.upperCanvasEl, "mousedown", this._onMouseDown), n(this.upperCanvasEl, "mousemove", this._onMouseMove), n(this.upperCanvasEl, "mouseout", this._onMouseOut), n(this.upperCanvasEl, "mouseenter", this._onMouseEnter), n(this.upperCanvasEl, "wheel", this._onMouseWheel), n(this.upperCanvasEl, "contextmenu", this._onContextMenu), n(this.upperCanvasEl, "touchstart", this._onMouseDown), n(this.upperCanvasEl, "touchmove", this._onMouseMove), "undefined" != typeof eventjs && "remove" in eventjs && (eventjs.remove(this.upperCanvasEl, "gesture", this._onGesture), eventjs.remove(this.upperCanvasEl, "drag", this._onDrag), eventjs.remove(this.upperCanvasEl, "orientation", this._onOrientationChange), eventjs.remove(this.upperCanvasEl, "shake", this._onShake), eventjs.remove(this.upperCanvasEl, "longpress", this._onLongPress)) }, _onGesture: function (e, t) { this.__onTransformGesture && this.__onTransformGesture(e, t) }, _onDrag: function (e, t) { this.__onDrag && this.__onDrag(e, t) }, _onMouseWheel: function (e) { this.__onMouseWheel(e) }, _onMouseOut: function (e) { var t = this._hoveredTarget; this.fire("mouse:out", { target: t, e: e }), this._hoveredTarget = null, t && t.fire("mouseout", { e: e }), this._iTextInstances && this._iTextInstances.forEach(function (e) { e.isEditing && e.hiddenTextarea.focus() }) }, _onMouseEnter: function (e) { this.findTarget(e) || (this.fire("mouse:over", { target: null, e: e }), this._hoveredTarget = null) }, _onOrientationChange: function (e, t) { this.__onOrientationChange && this.__onOrientationChange(e, t) }, _onShake: function (e, t) { this.__onShake && this.__onShake(e, t) }, _onLongPress: function (e, t) { this.__onLongPress && this.__onLongPress(e, t) }, _onContextMenu: function (e) { return this.stopContextMenu && (e.stopPropagation(), e.preventDefault()), !1 }, _onMouseDown: function (e) { this.__onMouseDown(e), t(fabric.document, "touchend", this._onMouseUp, { passive: !1 }), t(fabric.document, "touchmove", this._onMouseMove, { passive: !1 }), n(this.upperCanvasEl, "mousemove", this._onMouseMove), n(this.upperCanvasEl, "touchmove", this._onMouseMove), "touchstart" === e.type ? n(this.upperCanvasEl, "mousedown", this._onMouseDown) : (t(fabric.document, "mouseup", this._onMouseUp), t(fabric.document, "mousemove", this._onMouseMove)) }, _onMouseUp: function (e) { if (this.__onMouseUp(e), n(fabric.document, "mouseup", this._onMouseUp), n(fabric.document, "touchend", this._onMouseUp), n(fabric.document, "mousemove", this._onMouseMove), n(fabric.document, "touchmove", this._onMouseMove), t(this.upperCanvasEl, "mousemove", this._onMouseMove), t(this.upperCanvasEl, "touchmove", this._onMouseMove, { passive: !1 }), "touchend" === e.type) { var r = this; setTimeout(function () { t(r.upperCanvasEl, "mousedown", r._onMouseDown) }, 400) } }, _onMouseMove: function (e) { !this.allowTouchScrolling && e.preventDefault && e.preventDefault(), this.__onMouseMove(e) }, _onResize: function () { this.calcOffset() }, _shouldRender: function (e, t) { var n = this.getActiveGroup() || this.getActiveObject(); return n && n.isEditing && e === n ? !1 : !!(e && (e.isMoving || e !== n) || !e && n || !e && !n && !this._groupSelector || t && this._previousPointer && this.selection && (t.x !== this._previousPointer.x || t.y !== this._previousPointer.y)) }, __onMouseUp: function (e) { var t, n = !0, r = this._currentTransform, i = this._groupSelector, o = !i || 0 === i.left && 0 === i.top; if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e); r && (this._finalizeCurrentTransform(), n = !r.actionPerformed), t = n ? this.findTarget(e, !0) : r.target; var s = this._shouldRender(t, this.getPointer(e)); t || !o ? this._maybeGroupObjects(e) : (this._groupSelector = null, this._currentTransform = null), t && (t.isMoving = !1), this._handleCursorAndEvent(e, t, "up"), t && (t.__corner = 0), s && this.renderAll() }, _handleCursorAndEvent: function (e, t, n) { this._setCursorFromEvent(e, t), this._handleEvent(e, n, t ? t : null) }, _handleEvent: function (e, t, n) { var r = "undefined" == typeof n ? this.findTarget(e) : n, i = this.targets || [], o = { e: e, target: r, subTargets: i }; this.fire("mouse:" + t, o), r && r.fire("mouse" + t, o); for (var s = 0; s < i.length; s++) i[s].fire("mouse" + t, o) }, _finalizeCurrentTransform: function () { var e = this._currentTransform, t = e.target; t._scaling && (t._scaling = !1), t.setCoords(), this._restoreOriginXY(t), (e.actionPerformed || this.stateful && t.hasStateChanged()) && (this.fire("object:modified", { target: t }), t.fire("modified")) }, _restoreOriginXY: function (e) { if (this._previousOriginX && this._previousOriginY) { var t = e.translateToOriginPoint(e.getCenterPoint(), this._previousOriginX, this._previousOriginY); e.originX = this._previousOriginX, e.originY = this._previousOriginY, e.left = t.x, e.top = t.y, this._previousOriginX = null, this._previousOriginY = null } }, _onMouseDownInDrawingMode: function (e) { this._isCurrentlyDrawing = !0, this.discardActiveObject(e).renderAll(), this.clipTo && fabric.util.clipContext(this, this.contextTop); var t = this.getPointer(e); this.freeDrawingBrush.onMouseDown(t), this._handleEvent(e, "down") }, _onMouseMoveInDrawingMode: function (e) { if (this._isCurrentlyDrawing) { var t = this.getPointer(e); this.freeDrawingBrush.onMouseMove(t) } this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move") }, _onMouseUpInDrawingMode: function (e) { this._isCurrentlyDrawing = !1, this.clipTo && this.contextTop.restore(), this.freeDrawingBrush.onMouseUp(), this._handleEvent(e, "up") }, __onMouseDown: function (e) { var t = this.findTarget(e), n = "which" in e ? 3 === e.which : 2 === e.button; if (n) return void (this.fireRightClick && this._handleEvent(e, "down", t ? t : null)); var r = "which" in e ? 2 === e.which : 1 === e.button; if (r) return void (this.fireMiddleClick && this._handleEvent(e, "down", t ? t : null)); if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e); if (!this._currentTransform) { var i = this.getPointer(e, !0); this._previousPointer = i; var o = this._shouldRender(t, i), s = this._shouldGroup(e, t); if (this._shouldClearSelection(e, t) ? this._clearSelection(e, t, i) : s && (this._handleGrouping(e, t), t = this.getActiveGroup()), t) { !t.selectable || !t.__corner && s || (this._beforeTransform(e, t), this._setupCurrentTransform(e, t)); var a = this.getActiveObject(); t !== this.getActiveGroup() && t !== a && (this.deactivateAll(), t.selectable && (a && a.fire("deselected", { e: e }), this.setActiveObject(t, e))) } this._handleEvent(e, "down", t ? t : null), o && this.renderAll() } }, _beforeTransform: function (e, t) { this.stateful && t.saveState(), t._findTargetCorner(this.getPointer(e)) && this.onBeforeScaleRotate(t) }, _clearSelection: function (e, t, n) { this.deactivateAllWithDispatch(e), t && t.selectable ? this.setActiveObject(t, e) : this.selection && (this._groupSelector = { ex: n.x, ey: n.y, top: 0, left: 0 }) }, _setOriginToCenter: function (e) { this._previousOriginX = this._currentTransform.target.originX, this._previousOriginY = this._currentTransform.target.originY; var t = e.getCenterPoint(); e.originX = "center", e.originY = "center", e.left = t.x, e.top = t.y, this._currentTransform.left = e.left, this._currentTransform.top = e.top }, _setCenterToOrigin: function (e) { var t = e.translateToOriginPoint(e.getCenterPoint(), this._previousOriginX, this._previousOriginY); e.originX = this._previousOriginX, e.originY = this._previousOriginY, e.left = t.x, e.top = t.y, this._previousOriginX = null, this._previousOriginY = null }, __onMouseMove: function (e) { var t, n; if (this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e); if (!("undefined" != typeof e.touches && e.touches.length > 1)) { var r = this._groupSelector; r ? (n = this.getPointer(e, !0), r.left = n.x - r.ex, r.top = n.y - r.ey, this.renderTop()) : this._currentTransform ? this._transformObject(e) : (t = this.findTarget(e), this._setCursorFromEvent(e, t)), this._handleEvent(e, "move", t ? t : null) } }, __onMouseWheel: function (e) { this._handleEvent(e, "wheel") }, _transformObject: function (e) { var t = this.getPointer(e), n = this._currentTransform; n.reset = !1, n.target.isMoving = !0, n.shiftKey = e.shiftKey, n.altKey = e[this.centeredKey], this._beforeScaleTransform(e, n), this._performTransformAction(e, n, t), n.actionPerformed && this.renderAll() }, _performTransformAction: function (e, t, n) { var r = n.x, i = n.y, o = t.target, s = t.action, a = !1; "rotate" === s ? (a = this._rotateObject(r, i)) && this._fire("rotating", o, e) : "scale" === s ? (a = this._onScale(e, t, r, i)) && this._fire("scaling", o, e) : "scaleX" === s ? (a = this._scaleObject(r, i, "x")) && this._fire("scaling", o, e) : "scaleY" === s ? (a = this._scaleObject(r, i, "y")) && this._fire("scaling", o, e) : "skewX" === s ? (a = this._skewObject(r, i, "x")) && this._fire("skewing", o, e) : "skewY" === s ? (a = this._skewObject(r, i, "y")) && this._fire("skewing", o, e) : (a = this._translateObject(r, i), a && (this._fire("moving", o, e), this.setCursor(o.moveCursor || this.moveCursor))), t.actionPerformed = t.actionPerformed || a }, _fire: function (e, t, n) { this.fire("object:" + e, { target: t, e: n }), t.fire(e, { e: n }) }, _beforeScaleTransform: function (e, t) { if ("scale" === t.action || "scaleX" === t.action || "scaleY" === t.action) { var n = this._shouldCenterTransform(t.target); (n && ("center" !== t.originX || "center" !== t.originY) || !n && "center" === t.originX && "center" === t.originY) && (this._resetCurrentTransform(), t.reset = !0) } }, _onScale: function (e, t, n, r) { return !e[this.uniScaleKey] && !this.uniScaleTransform || t.target.get("lockUniScaling") ? (t.reset || "scale" !== t.currentAction || this._resetCurrentTransform(), t.currentAction = "scaleEqually", this._scaleObject(n, r, "equally")) : (t.currentAction = "scale", this._scaleObject(n, r)) }, _setCursorFromEvent: function (e, t) { if (!t || !t.selectable) return this.setCursor(this.defaultCursor), !1; var n = t.hoverCursor || this.hoverCursor, r = this.getActiveGroup(), i = t._findTargetCorner && (!r || !r.contains(t)) && t._findTargetCorner(this.getPointer(e, !0)); return i ? this._setCornerCursor(i, t, e) : this.setCursor(n), !0 }, _setCornerCursor: function (t, n, r) { if (t in e) this.setCursor(this._getRotatedCornerCursor(t, n, r)); else { if ("mtr" !== t || !n.hasRotatingPoint) return this.setCursor(this.defaultCursor), !1; this.setCursor(this.rotationCursor) } }, _getRotatedCornerCursor: function (t, n, r) { var i = Math.round(n.getAngle() % 360 / 45); return 0 > i && (i += 8), i += e[t], r[this.altActionKey] && e[t] % 2 === 0 && (i += 2), i %= 8, this.cursorMap[i] } }) }(); !function () { var e = Math.min, t = Math.max; fabric.util.object.extend(fabric.Canvas.prototype, { _shouldGroup: function (e, t) { var n = this.getActiveObject(); return e[this.selectionKey] && t && t.selectable && (this.getActiveGroup() || n && n !== t) && this.selection }, _handleGrouping: function (e, t) { var n = this.getActiveGroup(); (t !== n || (t = this.findTarget(e, !0))) && (n ? this._updateActiveGroup(t, e) : this._createActiveGroup(t, e), this._activeGroup && this._activeGroup.saveCoords()) }, _updateActiveGroup: function (e, t) { var n = this.getActiveGroup(); if (n.contains(e)) { if (n.removeWithUpdate(e), e.set("active", !1), 1 === n.size()) return this.discardActiveGroup(t), void this.setActiveObject(n.item(0)) } else n.addWithUpdate(e); this.fire("selection:created", { target: n, e: t }), n.set("active", !0) }, _createActiveGroup: function (e, t) { if (this._activeObject && e !== this._activeObject) { var n = this._createGroup(e); n.addWithUpdate(), this.setActiveGroup(n), this._activeObject = null, this.fire("selection:created", { target: n, e: t }) } e.set("active", !0) }, _createGroup: function (e) { var t = this.getObjects(), n = t.indexOf(this._activeObject) < t.indexOf(e), r = n ? [this._activeObject, e] : [e, this._activeObject]; return this._activeObject.isEditing && this._activeObject.exitEditing(), new fabric.Group(r, { canvas: this }) }, _groupSelectedObjects: function (e) { var t = this._collectObjects(); 1 === t.length ? this.setActiveObject(t[0], e) : t.length > 1 && (t = new fabric.Group(t.reverse(), { canvas: this }), t.addWithUpdate(), this.setActiveGroup(t, e), t.saveCoords(), this.fire("selection:created", { target: t }), this.renderAll()) }, _collectObjects: function () { for (var n, r = [], i = this._groupSelector.ex, o = this._groupSelector.ey, s = i + this._groupSelector.left, a = o + this._groupSelector.top, c = new fabric.Point(e(i, s), e(o, a)), u = new fabric.Point(t(i, s), t(o, a)), l = i === s && o === a, f = this._objects.length; f-- && (n = this._objects[f], !(n && n.selectable && n.visible && (n.intersectsWithRect(c, u) || n.isContainedWithinRect(c, u) || n.containsPoint(c) || n.containsPoint(u)) && (n.set("active", !0), r.push(n), l))) ;); return r }, _maybeGroupObjects: function (e) { this.selection && this._groupSelector && this._groupSelectedObjects(e); var t = this.getActiveGroup(); t && (t.setObjectsCoords().setCoords(), t.isMoving = !1, this.setCursor(this.defaultCursor)), this._groupSelector = null, this._currentTransform = null } }) }(); !function () { var e = fabric.StaticCanvas.supports("toDataURLWithQuality"); fabric.util.object.extend(fabric.StaticCanvas.prototype, { toDataURL: function (e) { e || (e = {}); var t = e.format || "png", n = e.quality || 1, r = e.multiplier || 1, i = { left: e.left || 0, top: e.top || 0, width: e.width || 0, height: e.height || 0 }; return this.__toDataURLWithMultiplier(t, n, i, r) }, __toDataURLWithMultiplier: function (e, t, n, r) { var i = this.getWidth(), o = this.getHeight(), s = (n.width || this.getWidth()) * r, a = (n.height || this.getHeight()) * r, c = this.getZoom(), u = c * r, l = this.viewportTransform, h = (l[4] - n.left) * r, f = (l[5] - n.top) * r, v = [u, 0, 0, u, h, f], d = this.interactive; this.viewportTransform = v, this.interactive && (this.interactive = !1), i !== s || o !== a ? this.setDimensions({ width: s, height: a }) : this.renderAll(); var p = this.__toDataURL(e, t, n); return d && (this.interactive = d), this.viewportTransform = l, this.setDimensions({ width: i, height: o }), p }, __toDataURL: function (t, n) { var r = this.contextContainer.canvas; "jpg" === t && (t = "jpeg"); var i = e ? r.toDataURL("image/" + t, n) : r.toDataURL("image/" + t); return i }, toDataURLWithMultiplier: function (e, t, n) { return this.toDataURL({ format: e, multiplier: t, quality: n }) } }) }(); !function () { var e = fabric.util.degreesToRadians, t = fabric.util.radiansToDegrees; fabric.util.object.extend(fabric.Canvas.prototype, { __onTransformGesture: function (e, t) { if (!this.isDrawingMode && e.touches && 2 === e.touches.length && "gesture" === t.gesture) { var n = this.findTarget(e); "undefined" != typeof n && (this.__gesturesParams = { e: e, self: t, target: n }, this.__gesturesRenderer()), this.fire("touch:gesture", { target: n, e: e, self: t }) } }, __gesturesParams: null, __gesturesRenderer: function () { if (null !== this.__gesturesParams && null !== this._currentTransform) { var e = this.__gesturesParams.self, t = this._currentTransform, n = this.__gesturesParams.e; t.action = "scale", t.originX = t.originY = "center", this._setOriginToCenter(t.target), this._scaleObjectBy(e.scale, n), 0 !== e.rotation && (t.action = "rotate", this._rotateObjectByAngle(e.rotation, n)), this._setCenterToOrigin(t.target), this.renderAll(), t.action = "drag" } }, __onDrag: function (e, t) { this.fire("touch:drag", { e: e, self: t }) }, __onOrientationChange: function (e, t) { this.fire("touch:orientation", { e: e, self: t }) }, __onShake: function (e, t) { this.fire("touch:shake", { e: e, self: t }) }, __onLongPress: function (e, t) { this.fire("touch:longpress", { e: e, self: t }) }, _scaleObjectBy: function (e, t) { var n = this._currentTransform, r = n.target, i = r.get("lockScalingX"), o = r.get("lockScalingY"); if (!i || !o) { r._scaling = !0; var s = r.translateToOriginPoint(r.getCenterPoint(), n.originX, n.originY), a = r._getTransformedDimensions(); this._setObjectScale(new fabric.Point(n.scaleX * a.x * e / r.scaleX, n.scaleY * a.y * e / r.scaleY), n, i, o, null, r.get("lockScalingFlip"), a), r.setPositionByOrigin(s, n.originX, n.originY), this._fire("scaling", r, t) } }, _rotateObjectByAngle: function (n, r) { var i = this._currentTransform; i.target.get("lockRotation") || (i.target.angle = t(e(n) + i.theta), this._fire("rotating", i.target, r)) } }) }(); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, n = e.util.object.clone, r = e.util.toFixed, o = e.util.string.capitalize, s = e.util.degreesToRadians, a = e.StaticCanvas.supports("setLineDash"), c = !e.isLikelyNode; e.Object || (e.Object = e.util.createClass(e.CommonMethods, { type: "object", originX: "left", originY: "top", top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, flipX: !1, flipY: !1, opacity: 1, angle: 0, skewX: 0, skewY: 0, cornerSize: 13, transparentCorners: !0, hoverCursor: null, moveCursor: null, padding: 0, borderColor: "rgba(102,153,255,0.75)", borderDashArray: null, cornerColor: "rgba(102,153,255,0.5)", cornerStrokeColor: null, cornerStyle: "rect", cornerDashArray: null, centeredScaling: !1, centeredRotation: !0, fill: "rgb(0,0,0)", fillRule: "nonzero", globalCompositeOperation: "source-over", backgroundColor: "", selectionBackgroundColor: "", stroke: null, strokeWidth: 1, strokeDashArray: null, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 10, shadow: null, borderOpacityWhenMoving: .4, borderScaleFactor: 1, transformMatrix: null, minScaleLimit: .01, selectable: !0, evented: !0, visible: !0, hasControls: !0, hasBorders: !0, hasRotatingPoint: !0, rotatingPointOffset: 40, perPixelTargetFind: !1, includeDefaultValues: !0, clipTo: null, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockUniScaling: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, excludeFromExport: !1, objectCaching: c, statefullCache: !1, noScaleCache: !0, dirty: !1, needsItsOwnCache: !1, stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor skewX skewY".split(" "), cacheProperties: "fill stroke strokeWidth strokeDashArray width height stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit fillRule backgroundColor".split(" "), initialize: function (t) { t = t || {}, t && this.setOptions(t), this.objectCaching && (this._createCacheCanvas(), this.setupState({ propertySet: "cacheProperties" })) }, _createCacheCanvas: function () { this._cacheCanvas = e.document.createElement("canvas"), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas() }, _getCacheCanvasDimensions: function () { var t = this.canvas && this.canvas.getZoom() || 1, i = this.getObjectScaling(), n = this._getNonTransformedDimensions(), r = this.canvas && this.canvas._isRetinaScaling() ? e.devicePixelRatio : 1, o = i.scaleX * t * r, s = i.scaleY * t * r, a = n.x * o, c = n.y * s; return { width: a + 2, height: c + 2, zoomX: o, zoomY: s } }, _updateCacheCanvas: function () { if (this.noScaleCache && this.canvas && this.canvas._currentTransform) { var t = this.canvas._currentTransform.action; if ("scale" === t.slice(0, 5)) return !1 } var e = this._getCacheCanvasDimensions(), i = e.width, n = e.height, r = e.zoomX, o = e.zoomY; return i !== this.cacheWidth || n !== this.cacheHeight ? (this._cacheCanvas.width = Math.ceil(i), this._cacheCanvas.height = Math.ceil(n), this._cacheContext.translate(i / 2, n / 2), this._cacheContext.scale(r, o), this.cacheWidth = i, this.cacheHeight = n, this.zoomX = r, this.zoomY = o, !0) : !1 }, setOptions: function (t) { this._setOptions(t), this._initGradient(t.fill, "fill"), this._initGradient(t.stroke, "stroke"), this._initClipping(t), this._initPattern(t.fill, "fill"), this._initPattern(t.stroke, "stroke") }, transform: function (t, e) { this.group && !this.group._transformDone && this.group === this.canvas._activeGroup && this.group.transform(t); var i = e ? this._getLeftTopCoords() : this.getCenterPoint(); t.translate(i.x, i.y), this.angle && t.rotate(s(this.angle)), t.scale(this.scaleX * (this.flipX ? -1 : 1), this.scaleY * (this.flipY ? -1 : 1)), this.skewX && t.transform(1, 0, Math.tan(s(this.skewX)), 1, 0, 0), this.skewY && t.transform(1, Math.tan(s(this.skewY)), 0, 1, 0, 0) }, toObject: function (t) { var i = e.Object.NUM_FRACTION_DIGITS, n = { type: this.type, originX: this.originX, originY: this.originY, left: r(this.left, i), top: r(this.top, i), width: r(this.width, i), height: r(this.height, i), fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill, stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke, strokeWidth: r(this.strokeWidth, i), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: r(this.strokeMiterLimit, i), scaleX: r(this.scaleX, i), scaleY: r(this.scaleY, i), angle: r(this.getAngle(), i), flipX: this.flipX, flipY: this.flipY, opacity: r(this.opacity, i), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, clipTo: this.clipTo && String(this.clipTo), backgroundColor: this.backgroundColor, fillRule: this.fillRule, globalCompositeOperation: this.globalCompositeOperation, transformMatrix: this.transformMatrix ? this.transformMatrix.concat() : null, skewX: r(this.skewX, i), skewY: r(this.skewY, i) }; return e.util.populateWithProperties(this, n, t), this.includeDefaultValues || (n = this._removeDefaultValues(n)), n }, toDatalessObject: function (t) { return this.toObject(t) }, _removeDefaultValues: function (t) { var i = e.util.getKlass(t.type).prototype, n = i.stateProperties; return n.forEach(function (e) { t[e] === i[e] && delete t[e]; var n = "[object Array]" === Object.prototype.toString.call(t[e]) && "[object Array]" === Object.prototype.toString.call(i[e]); n && 0 === t[e].length && 0 === i[e].length && delete t[e] }), t }, toString: function () { return "#<fabric." + o(this.type) + ">" }, getObjectScaling: function () { var t = this.scaleX, e = this.scaleY; if (this.group) { var i = this.group.getObjectScaling(); t *= i.scaleX, e *= i.scaleY } return { scaleX: t, scaleY: e } }, _set: function (t, i) { var n = "scaleX" === t || "scaleY" === t; return n && (i = this._constrainScale(i)), "scaleX" === t && 0 > i ? (this.flipX = !this.flipX, i *= -1) : "scaleY" === t && 0 > i ? (this.flipY = !this.flipY, i *= -1) : "shadow" !== t || !i || i instanceof e.Shadow ? "dirty" === t && this.group && this.group.set("dirty", i) : i = new e.Shadow(i), this[t] = i, this.cacheProperties.indexOf(t) > -1 && (this.group && this.group.set("dirty", !0), this.dirty = !0), this.group && this.stateProperties.indexOf(t) > -1 && this.group.set("dirty", !0), ("width" === t || "height" === t) && (this.minScaleLimit = Math.min(.1, 1 / Math.max(this.width, this.height))), this }, setOnGroup: function () { }, setSourcePath: function (t) { return this.sourcePath = t, this }, getViewportTransform: function () { return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : e.iMatrix.concat() }, render: function (t, i) { 0 === this.width && 0 === this.height || !this.visible || (!this.canvas || !this.canvas.skipOffscreen || this.group || this.isOnScreen()) && (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), i || this.transform(t), this._setOpacity(t), this._setShadow(t), this.transformMatrix && t.transform.apply(t, this.transformMatrix), this.clipTo && e.util.clipContext(this, t), !this.objectCaching || this.group && !this.needsItsOwnCache ? (this.drawObject(t, i), i && this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })) : (this._cacheCanvas || this._createCacheCanvas(), this.isCacheDirty(i) && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, i), this.dirty = !1), this.drawCacheOnCanvas(t)), this.clipTo && t.restore(), t.restore()) }, drawObject: function (t, e) { this._renderBackground(t), this._setStrokeStyles(t), this._setFillStyles(t), this._render(t, e) }, drawCacheOnCanvas: function (t) { t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheWidth / 2, -this.cacheHeight / 2) }, isCacheDirty: function (t) { if (!t && this._updateCacheCanvas()) return !0; if (this.dirty || this.statefullCache && this.hasStateChanged("cacheProperties")) { if (!t) { var e = this.cacheWidth / this.zoomX, i = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-e / 2, -i / 2, e, i) } return !0 } return !1 }, _renderBackground: function (t) { if (this.backgroundColor) { var e = this._getNonTransformedDimensions(); t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t) } }, _setOpacity: function (t) { t.globalAlpha *= this.opacity }, _setStrokeStyles: function (t) { this.stroke && (t.lineWidth = this.strokeWidth, t.lineCap = this.strokeLineCap, t.lineJoin = this.strokeLineJoin, t.miterLimit = this.strokeMiterLimit, t.strokeStyle = this.stroke.toLive ? this.stroke.toLive(t, this) : this.stroke) }, _setFillStyles: function (t) { this.fill && (t.fillStyle = this.fill.toLive ? this.fill.toLive(t, this) : this.fill) }, _setLineDash: function (t, e, i) { e && (1 & e.length && e.push.apply(e, e), a ? t.setLineDash(e) : i && i(t)) }, _renderControls: function (t, i) { if (!(!this.active || i || this.group && this.group !== this.canvas.getActiveGroup())) { var n, r = this.getViewportTransform(), o = this.calcTransformMatrix(); o = e.util.multiplyTransformMatrices(r, o), n = e.util.qrDecompose(o), t.save(), t.translate(n.translateX, n.translateY), t.lineWidth = 1 * this.borderScaleFactor, this.group || (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.group && this.group === this.canvas.getActiveGroup() ? (t.rotate(s(n.angle)), this.drawBordersInGroup(t, n)) : (t.rotate(s(this.angle)), this.drawBorders(t)), this.drawControls(t), t.restore() } }, _setShadow: function (t) { if (this.shadow) { var i = this.canvas && this.canvas.viewportTransform[0] || 1, n = this.canvas && this.canvas.viewportTransform[3] || 1, r = this.getObjectScaling(); this.canvas && this.canvas._isRetinaScaling() && (i *= e.devicePixelRatio, n *= e.devicePixelRatio), t.shadowColor = this.shadow.color, t.shadowBlur = this.shadow.blur * (i + n) * (r.scaleX + r.scaleY) / 4, t.shadowOffsetX = this.shadow.offsetX * i * r.scaleX, t.shadowOffsetY = this.shadow.offsetY * n * r.scaleY } }, _removeShadow: function (t) { this.shadow && (t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0) }, _applyPatternGradientTransform: function (t, e) { if (e.toLive) { var i = e.gradientTransform || e.patternTransform; i && t.transform.apply(t, i); var n = -this.width / 2 + e.offsetX || 0, r = -this.height / 2 + e.offsetY || 0; t.translate(n, r) } }, _renderFill: function (t) { this.fill && (t.save(), this._applyPatternGradientTransform(t, this.fill), "evenodd" === this.fillRule ? t.fill("evenodd") : t.fill(), t.restore()) }, _renderStroke: function (t) { this.stroke && 0 !== this.strokeWidth && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray, this._renderDashedStroke), this._applyPatternGradientTransform(t, this.stroke), t.stroke(), t.restore()) }, clone: function (t, i) { return this.constructor.fromObject ? this.constructor.fromObject(this.toObject(i), t) : new e.Object(this.toObject(i)) }, cloneAsImage: function (t, i) { var n = this.toDataURL(i); return e.util.loadImage(n, function (i) { t && t(new e.Image(i)) }), this }, toDataURL: function (t) { t || (t = {}); var i = e.util.createCanvasElement(), n = this.getBoundingRect(); i.width = n.width, i.height = n.height, e.util.wrapElement(i, "div"); var r = new e.StaticCanvas(i, { enableRetinaScaling: t.enableRetinaScaling }); "jpg" === t.format && (t.format = "jpeg"), "jpeg" === t.format && (r.backgroundColor = "#fff"); var o = { active: this.get("active"), left: this.getLeft(), top: this.getTop() }; this.set("active", !1), this.setPositionByOrigin(new e.Point(r.getWidth() / 2, r.getHeight() / 2), "center", "center"); var s = this.canvas; r.add(this); var a = r.toDataURL(t); return this.set(o).setCoords(), this.canvas = s, r.dispose(), r = null, a }, isType: function (t) { return this.type === t }, complexity: function () { return 1 }, toJSON: function (t) { return this.toObject(t) }, setGradient: function (t, i) { i || (i = {}); var n = { colorStops: [] }; return n.type = i.type || (i.r1 || i.r2 ? "radial" : "linear"), n.coords = { x1: i.x1, y1: i.y1, x2: i.x2, y2: i.y2 }, (i.r1 || i.r2) && (n.coords.r1 = i.r1, n.coords.r2 = i.r2), n.gradientTransform = i.gradientTransform, e.Gradient.prototype.addColorStop.call(n, i.colorStops), this.set(t, e.Gradient.forObject(this, n)) }, setPatternFill: function (t) { return this.set("fill", new e.Pattern(t)) }, setShadow: function (t) { return this.set("shadow", t ? new e.Shadow(t) : null) }, setColor: function (t) { return this.set("fill", t), this }, setAngle: function (t) { var e = ("center" !== this.originX || "center" !== this.originY) && this.centeredRotation; return e && this._setOriginToCenter(), this.set("angle", t), e && this._resetOrigin(), this }, centerH: function () { return this.canvas && this.canvas.centerObjectH(this), this }, viewportCenterH: function () { return this.canvas && this.canvas.viewportCenterObjectH(this), this }, centerV: function () { return this.canvas && this.canvas.centerObjectV(this), this }, viewportCenterV: function () { return this.canvas && this.canvas.viewportCenterObjectV(this), this }, center: function () { return this.canvas && this.canvas.centerObject(this), this }, viewportCenter: function () { return this.canvas && this.canvas.viewportCenterObject(this), this }, remove: function () { return this.canvas && this.canvas.remove(this), this }, getLocalPointer: function (t, i) { i = i || this.canvas.getPointer(t); var n = new e.Point(i.x, i.y), r = this._getLeftTopCoords(); return this.angle && (n = e.util.rotatePoint(n, r, s(-this.angle))), { x: n.x - r.x, y: n.y - r.y } }, _setupCompositeOperation: function (t) { this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation) } }), e.util.createAccessors(e.Object), e.Object.prototype.rotate = e.Object.prototype.setAngle, i(e.Object.prototype, e.Observable), e.Object.NUM_FRACTION_DIGITS = 2, e.Object._fromObject = function (t, i, r, o, s) { var a = e[t]; if (i = n(i, !0), !o) { var c = s ? new a(i[s], i) : new a(i); return r && r(c), c } e.util.enlivenPatterns([i.fill, i.stroke], function (t) { "undefined" != typeof t[0] && (i.fill = t[0]), "undefined" != typeof t[1] && (i.stroke = t[1]); var e = s ? new a(i[s], i) : new a(i); r && r(e) }) }, e.Object.__uid = 0) }("undefined" != typeof exports ? exports : this); !function () { var e = fabric.util.degreesToRadians, t = { left: -.5, center: 0, right: .5 }, n = { top: -.5, center: 0, bottom: .5 }; fabric.util.object.extend(fabric.Object.prototype, { translateToGivenOrigin: function (e, r, i, o, s) { var a, c, u, l = e.x, h = e.y; return "string" == typeof r ? r = t[r] : r -= .5, "string" == typeof o ? o = t[o] : o -= .5, a = o - r, "string" == typeof i ? i = n[i] : i -= .5, "string" == typeof s ? s = n[s] : s -= .5, c = s - i, (a || c) && (u = this._getTransformedDimensions(), l = e.x + a * u.x, h = e.y + c * u.y), new fabric.Point(l, h) }, translateToCenterPoint: function (t, n, r) { var i = this.translateToGivenOrigin(t, n, r, "center", "center"); return this.angle ? fabric.util.rotatePoint(i, t, e(this.angle)) : i }, translateToOriginPoint: function (t, n, r) { var i = this.translateToGivenOrigin(t, "center", "center", n, r); return this.angle ? fabric.util.rotatePoint(i, t, e(this.angle)) : i }, getCenterPoint: function () { var e = new fabric.Point(this.left, this.top); return this.translateToCenterPoint(e, this.originX, this.originY) }, getPointByOrigin: function (e, t) { var n = this.getCenterPoint(); return this.translateToOriginPoint(n, e, t) }, toLocalPoint: function (t, n, r) { var i, o, s = this.getCenterPoint(); return i = "undefined" != typeof n && "undefined" != typeof r ? this.translateToGivenOrigin(s, "center", "center", n, r) : new fabric.Point(this.left, this.top), o = new fabric.Point(t.x, t.y), this.angle && (o = fabric.util.rotatePoint(o, s, -e(this.angle))), o.subtractEquals(i) }, setPositionByOrigin: function (e, t, n) { var r = this.translateToCenterPoint(e, t, n), i = this.translateToOriginPoint(r, this.originX, this.originY); this.set("left", i.x), this.set("top", i.y) }, adjustPosition: function (n) { var r, i, o = e(this.angle), s = this.getWidth(), a = Math.cos(o) * s, c = Math.sin(o) * s; r = "string" == typeof this.originX ? t[this.originX] : this.originX - .5, i = "string" == typeof n ? t[n] : n - .5, this.left += a * (i - r), this.top += c * (i - r), this.setCoords(), this.originX = n }, _setOriginToCenter: function () { this._originalOriginX = this.originX, this._originalOriginY = this.originY; var e = this.getCenterPoint(); this.originX = "center", this.originY = "center", this.left = e.x, this.top = e.y }, _resetOrigin: function () { var e = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY); this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = e.x, this.top = e.y, this._originalOriginX = null, this._originalOriginY = null }, _getLeftTopCoords: function () { return this.translateToOriginPoint(this.getCenterPoint(), "left", "top") } }) }(); !function () { function e(e) { return [new fabric.Point(e.tl.x, e.tl.y), new fabric.Point(e.tr.x, e.tr.y), new fabric.Point(e.br.x, e.br.y), new fabric.Point(e.bl.x, e.bl.y)] } var t = fabric.util.degreesToRadians, n = fabric.util.multiplyTransformMatrices; fabric.util.object.extend(fabric.Object.prototype, { oCoords: null, aCoords: null, getCoords: function (t, n) { this.oCoords || this.setCoords(); var r = t ? this.aCoords : this.oCoords; return e(n ? this.calcCoords(t) : r) }, intersectsWithRect: function (e, t, n, r) { var i = this.getCoords(n, r), o = fabric.Intersection.intersectPolygonRectangle(i, e, t); return "Intersection" === o.status }, intersectsWithObject: function (e, t, n) { var r = fabric.Intersection.intersectPolygonPolygon(this.getCoords(t, n), e.getCoords(t, n)); return "Intersection" === r.status || e.isContainedWithinObject(this, t, n) || this.isContainedWithinObject(e, t, n) }, isContainedWithinObject: function (e, t, n) { for (var r = this.getCoords(t, n), i = 0, o = e._getImageLines(n ? e.calcCoords(t) : t ? e.aCoords : e.oCoords) ; 4 > i; i++) if (!e.containsPoint(r[i], o)) return !1; return !0 }, isContainedWithinRect: function (e, t, n, r) { var i = this.getBoundingRect(n, r); return i.left >= e.x && i.left + i.width <= t.x && i.top >= e.y && i.top + i.height <= t.y }, containsPoint: function (e, t, n, r) { var t = t || this._getImageLines(r ? this.calcCoords(n) : n ? this.aCoords : this.oCoords), i = this._findCrossPoints(e, t); return 0 !== i && i % 2 === 1 }, isOnScreen: function (e) { if (!this.canvas) return !1; for (var t, n = this.canvas.vptCoords.tl, r = this.canvas.vptCoords.br, i = this.getCoords(!0, e), o = 0; 4 > o; o++) if (t = i[o], t.x <= r.x && t.x >= n.x && t.y <= r.y && t.y >= n.y) return !0; if (this.intersectsWithRect(n, r, !0)) return !0; var s = { x: (n.x + r.x) / 2, y: (n.y + r.y) / 2 }; return this.containsPoint(s, null, !0) ? !0 : !1 }, _getImageLines: function (e) { return { topline: { o: e.tl, d: e.tr }, rightline: { o: e.tr, d: e.br }, bottomline: { o: e.br, d: e.bl }, leftline: { o: e.bl, d: e.tl } } }, _findCrossPoints: function (e, t) { var n, r, i, o, s, a, c = 0; for (var u in t) if (a = t[u], !(a.o.y < e.y && a.d.y < e.y || a.o.y >= e.y && a.d.y >= e.y || (a.o.x === a.d.x && a.o.x >= e.x ? s = a.o.x : (n = 0, r = (a.d.y - a.o.y) / (a.d.x - a.o.x), i = e.y - n * e.x, o = a.o.y - r * a.o.x, s = -(i - o) / (n - r)), s >= e.x && (c += 1), 2 !== c))) break; return c }, getBoundingRectWidth: function () { return this.getBoundingRect().width }, getBoundingRectHeight: function () { return this.getBoundingRect().height }, getBoundingRect: function (e, t) { var n = this.getCoords(e, t); return fabric.util.makeBoundingBoxFromPoints(n) }, getWidth: function () { return this._getTransformedDimensions().x }, getHeight: function () { return this._getTransformedDimensions().y }, _constrainScale: function (e) { return Math.abs(e) < this.minScaleLimit ? 0 > e ? -this.minScaleLimit : this.minScaleLimit : e }, scale: function (e) { return e = this._constrainScale(e), 0 > e && (this.flipX = !this.flipX, this.flipY = !this.flipY, e *= -1), this.scaleX = e, this.scaleY = e, this.setCoords() }, scaleToWidth: function (e) { var t = this.getBoundingRect().width / this.getWidth(); return this.scale(e / this.width / t) }, scaleToHeight: function (e) { var t = this.getBoundingRect().height / this.getHeight(); return this.scale(e / this.height / t) }, calcCoords: function (e) { var n = t(this.angle), r = this.getViewportTransform(), i = e ? this._getTransformedDimensions() : this._calculateCurrentDimensions(), o = i.x, s = i.y, a = Math.sin(n), c = Math.cos(n), u = o > 0 ? Math.atan(s / o) : 0, l = o / Math.cos(u) / 2, h = Math.cos(u + n) * l, f = Math.sin(u + n) * l, v = this.getCenterPoint(), d = e ? v : fabric.util.transformPoint(v, r), g = new fabric.Point(d.x - h, d.y - f), p = new fabric.Point(g.x + o * c, g.y + o * a), m = new fabric.Point(g.x - s * a, g.y + s * c), y = new fabric.Point(d.x + h, d.y + f); if (!e) var b = new fabric.Point((g.x + m.x) / 2, (g.y + m.y) / 2), _ = new fabric.Point((p.x + g.x) / 2, (p.y + g.y) / 2), w = new fabric.Point((y.x + p.x) / 2, (y.y + p.y) / 2), x = new fabric.Point((y.x + m.x) / 2, (y.y + m.y) / 2), C = new fabric.Point(_.x + a * this.rotatingPointOffset, _.y - c * this.rotatingPointOffset); var d = { tl: g, tr: p, br: y, bl: m }; return e || (d.ml = b, d.mt = _, d.mr = w, d.mb = x, d.mtr = C), d }, setCoords: function (e, t) { return this.oCoords = this.calcCoords(e), t || (this.aCoords = this.calcCoords(!0)), e || this._setCornerCoords && this._setCornerCoords(), this }, _calcRotateMatrix: function () { if (this.angle) { var e = t(this.angle), n = Math.cos(e), r = Math.sin(e); return [n, r, -r, n, 0, 0] } return fabric.iMatrix.concat() }, calcTransformMatrix: function (e) { var t = this.getCenterPoint(), r = [1, 0, 0, 1, t.x, t.y], i = this._calcRotateMatrix(), o = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, !0), s = this.group && !e ? this.group.calcTransformMatrix() : fabric.iMatrix.concat(); return s = n(s, r), s = n(s, i), s = n(s, o) }, _calcDimensionsTransformMatrix: function (e, r, i) { var o = [1, 0, Math.tan(t(e)), 1], s = [1, Math.tan(t(r)), 0, 1], a = this.scaleX * (i && this.flipX ? -1 : 1), c = this.scaleY * (i && this.flipY ? -1 : 1), u = [a, 0, 0, c], l = n(u, o, !0); return n(l, s, !0) }, _getNonTransformedDimensions: function () { var e = this.strokeWidth, t = this.width + e, n = this.height + e; return { x: t, y: n } }, _getTransformedDimensions: function (e, t) { "undefined" == typeof e && (e = this.skewX), "undefined" == typeof t && (t = this.skewY); var n, r, i = this._getNonTransformedDimensions(), o = i.x / 2, s = i.y / 2, a = [{ x: -o, y: -s }, { x: o, y: -s }, { x: -o, y: s }, { x: o, y: s }], c = this._calcDimensionsTransformMatrix(e, t, !1); for (n = 0; n < a.length; n++) a[n] = fabric.util.transformPoint(a[n], c); return r = fabric.util.makeBoundingBoxFromPoints(a), { x: r.width, y: r.height } }, _calculateCurrentDimensions: function () { var e = this.getViewportTransform(), t = this._getTransformedDimensions(), n = fabric.util.transformPoint(t, e, !0); return n.scalarAdd(2 * this.padding) } }) }(); fabric.util.object.extend(fabric.Object.prototype, { sendToBack: function () { return this.group ? fabric.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas.sendToBack(this), this }, bringToFront: function () { return this.group ? fabric.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas.bringToFront(this), this }, sendBackwards: function (t) { return this.group ? fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, t) : this.canvas.sendBackwards(this, t), this }, bringForward: function (t) { return this.group ? fabric.StaticCanvas.prototype.bringForward.call(this.group, this, t) : this.canvas.bringForward(this, t), this }, moveTo: function (t) { return this.group ? fabric.StaticCanvas.prototype.moveTo.call(this.group, this, t) : this.canvas.moveTo(this, t), this } }); !function () { function t(t, e) { if (e) { if (e.toLive) return t + ": url(#SVGID_" + e.id + "); "; var i = new fabric.Color(e), r = t + ": " + i.toRgb() + "; ", n = i.getAlpha(); return 1 !== n && (r += t + "-opacity: " + n.toString() + "; "), r } return t + ": none; " } fabric.util.object.extend(fabric.Object.prototype, { getSvgStyles: function (e) { var i = this.fillRule, r = this.strokeWidth ? this.strokeWidth : "0", n = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", o = this.strokeLineCap ? this.strokeLineCap : "butt", s = this.strokeLineJoin ? this.strokeLineJoin : "miter", a = this.strokeMiterLimit ? this.strokeMiterLimit : "4", c = "undefined" != typeof this.opacity ? this.opacity : "1", h = this.visible ? "" : " visibility: hidden;", u = e ? "" : this.getSvgFilter(), l = t("fill", this.fill), f = t("stroke", this.stroke); return [f, "stroke-width: ", r, "; ", "stroke-dasharray: ", n, "; ", "stroke-linecap: ", o, "; ", "stroke-linejoin: ", s, "; ", "stroke-miterlimit: ", a, "; ", l, "fill-rule: ", i, "; ", "opacity: ", c, ";", u, h].join("") }, getSvgFilter: function () { return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "" }, getSvgId: function () { return this.id ? 'id="' + this.id + '" ' : "" }, getSvgTransform: function () { if (this.group && "path-group" === this.group.type) return ""; var t = fabric.util.toFixed, e = this.getAngle(), i = this.getSkewX() % 360, r = this.getSkewY() % 360, n = this.getCenterPoint(), o = fabric.Object.NUM_FRACTION_DIGITS, s = "path-group" === this.type ? "" : "translate(" + t(n.x, o) + " " + t(n.y, o) + ")", a = 0 !== e ? " rotate(" + t(e, o) + ")" : "", c = 1 === this.scaleX && 1 === this.scaleY ? "" : " scale(" + t(this.scaleX, o) + " " + t(this.scaleY, o) + ")", h = 0 !== i ? " skewX(" + t(i, o) + ")" : "", u = 0 !== r ? " skewY(" + t(r, o) + ")" : "", l = "path-group" === this.type ? this.width : 0, f = this.flipX ? " matrix(-1 0 0 1 " + l + " 0) " : "", d = "path-group" === this.type ? this.height : 0, g = this.flipY ? " matrix(1 0 0 -1 0 " + d + ")" : ""; return [s, a, c, f, g, h, u].join("") }, getSvgTransformMatrix: function () { return this.transformMatrix ? " matrix(" + this.transformMatrix.join(" ") + ") " : "" }, _createBaseSVGMarkup: function () { var t = []; return this.fill && this.fill.toLive && t.push(this.fill.toSVG(this, !1)), this.stroke && this.stroke.toLive && t.push(this.stroke.toSVG(this, !1)), this.shadow && t.push(this.shadow.toSVG(this)), t } }) }(); !function () { function t(t, e, r) { var n = {}, o = !0; r.forEach(function (e) { n[e] = t[e] }), i(t[e], n, o) } function e(t, i, r) { if (!fabric.isLikelyNode && t instanceof Element) return t === i; if (t instanceof Array) { if (t.length !== i.length) return !1; for (var n = 0, o = t.length; o > n; n++) if (t[n] !== i[n]) return !1; return !0 } if (t && "object" == typeof t) { if (!r && Object.keys(t).length !== Object.keys(i).length) return !1; for (var s in t) if (!e(t[s], i[s])) return !1; return !0 } return t === i } var i = fabric.util.object.extend, r = "stateProperties"; fabric.util.object.extend(fabric.Object.prototype, { hasStateChanged: function (t) { return t = t || r, t = "_" + t, !e(this[t], this, !0) }, saveState: function (e) { var i = e && e.propertySet || r, n = "_" + i; return this[n] ? (t(this, n, this[i]), e && e.stateProperties && t(this, n, e.stateProperties), this) : this.setupState(e) }, setupState: function (t) { t = t || {}; var e = t.propertySet || r; return t.propertySet = e, this["_" + e] = {}, this.saveState(t), this } }) }(); !function () { var t = fabric.util.degreesToRadians, e = function () { return "undefined" != typeof G_vmlCanvasManager }; fabric.util.object.extend(fabric.Object.prototype, { _controlsVisibility: null, _findTargetCorner: function (t) { if (!this.hasControls || !this.active) return !1; var e, i, r = t.x, n = t.y; this.__corner = 0; for (var o in this.oCoords) if (this.isControlVisible(o) && ("mtr" !== o || this.hasRotatingPoint) && (!this.get("lockUniScaling") || "mt" !== o && "mr" !== o && "mb" !== o && "ml" !== o) && (i = this._getImageLines(this.oCoords[o].corner), e = this._findCrossPoints({ x: r, y: n }, i), 0 !== e && e % 2 === 1)) return this.__corner = o, o; return !1 }, _setCornerCoords: function () { var e, i, r = this.oCoords, n = t(45 - this.angle), o = .707106 * this.cornerSize, s = o * Math.cos(n), a = o * Math.sin(n); for (var c in r) e = r[c].x, i = r[c].y, r[c].corner = { tl: { x: e - a, y: i - s }, tr: { x: e + s, y: i - a }, bl: { x: e - s, y: i + a }, br: { x: e + a, y: i + s } } }, drawSelectionBackground: function (e) { if (!this.selectionBackgroundColor || this.group || !this.active) return this; e.save(); var i = this.getCenterPoint(), r = this._calculateCurrentDimensions(), n = this.canvas.viewportTransform; return e.translate(i.x, i.y), e.scale(1 / n[0], 1 / n[3]), e.rotate(t(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-r.x / 2, -r.y / 2, r.x, r.y), e.restore(), this }, drawBorders: function (t) { if (!this.hasBorders) return this; var e = this._calculateCurrentDimensions(), i = 1 / this.borderScaleFactor, r = e.x + i, n = e.y + i; if (t.save(), t.strokeStyle = this.borderColor, this._setLineDash(t, this.borderDashArray, null), t.strokeRect(-r / 2, -n / 2, r, n), this.hasRotatingPoint && this.isControlVisible("mtr") && !this.get("lockRotation") && this.hasControls) { var o = -n / 2; t.beginPath(), t.moveTo(0, o), t.lineTo(0, o - this.rotatingPointOffset), t.closePath(), t.stroke() } return t.restore(), this }, drawBordersInGroup: function (t, e) { if (!this.hasBorders) return this; var i = this._getNonTransformedDimensions(), r = fabric.util.customTransformMatrix(e.scaleX, e.scaleY, e.skewX), n = fabric.util.transformPoint(i, r), o = 1 / this.borderScaleFactor, s = n.x + o, a = n.y + o; return t.save(), this._setLineDash(t, this.borderDashArray, null), t.strokeStyle = this.borderColor, t.strokeRect(-s / 2, -a / 2, s, a), t.restore(), this }, drawControls: function (t) { if (!this.hasControls) return this; var e = this._calculateCurrentDimensions(), i = e.x, r = e.y, n = this.cornerSize, o = -(i + n) / 2, s = -(r + n) / 2, a = this.transparentCorners ? "stroke" : "fill"; return t.save(), t.strokeStyle = t.fillStyle = this.cornerColor, this.transparentCorners || (t.strokeStyle = this.cornerStrokeColor), this._setLineDash(t, this.cornerDashArray, null), this._drawControl("tl", t, a, o, s), this._drawControl("tr", t, a, o + i, s), this._drawControl("bl", t, a, o, s + r), this._drawControl("br", t, a, o + i, s + r), this.get("lockUniScaling") || (this._drawControl("mt", t, a, o + i / 2, s), this._drawControl("mb", t, a, o + i / 2, s + r), this._drawControl("mr", t, a, o + i, s + r / 2), this._drawControl("ml", t, a, o, s + r / 2)), this.hasRotatingPoint && this._drawControl("mtr", t, a, o + i / 2, s - this.rotatingPointOffset), t.restore(), this }, _drawControl: function (t, i, r, n, o) { if (this.isControlVisible(t)) { var s = this.cornerSize, a = !this.transparentCorners && this.cornerStrokeColor; switch (this.cornerStyle) { case "circle": i.beginPath(), i.arc(n + s / 2, o + s / 2, s / 2, 0, 2 * Math.PI, !1), i[r](), a && i.stroke(); break; default: e() || this.transparentCorners || i.clearRect(n, o, s, s), i[r + "Rect"](n, o, s, s), a && i.strokeRect(n, o, s, s) } } }, isControlVisible: function (t) { return this._getControlsVisibility()[t] }, setControlVisible: function (t, e) { return this._getControlsVisibility()[t] = e, this }, setControlsVisibility: function (t) { t || (t = {}); for (var e in t) this.setControlVisible(e, t[e]); return this }, _getControlsVisibility: function () { return this._controlsVisibility || (this._controlsVisibility = { tl: !0, tr: !0, br: !0, bl: !0, ml: !0, mt: !0, mr: !0, mb: !0, mtr: !0 }), this._controlsVisibility } }) }(); !function (t) { "use strict"; function e(t, e) { var i = t.origin, r = t.axis1, n = t.axis2, o = t.dimension, s = e.nearest, a = e.center, c = e.farthest; return function () { switch (this.get(i)) { case s: return Math.min(this.get(r), this.get(n)); case a: return Math.min(this.get(r), this.get(n)) + .5 * this.get(o); case c: return Math.max(this.get(r), this.get(n)) } } } var i = t.fabric || (t.fabric = {}), r = i.util.object.extend, n = i.util.object.clone, o = { x1: 1, x2: 1, y1: 1, y2: 1 }, s = i.StaticCanvas.supports("setLineDash"); if (i.Line) return void i.warn("fabric.Line is already defined"); var a = i.Object.prototype.cacheProperties.concat(); a.push("x1", "x2", "y1", "y2"), i.Line = i.util.createClass(i.Object, { type: "line", x1: 0, y1: 0, x2: 0, y2: 0, cacheProperties: a, initialize: function (t, e) { t || (t = [0, 0, 0, 0]), this.callSuper("initialize", e), this.set("x1", t[0]), this.set("y1", t[1]), this.set("x2", t[2]), this.set("y2", t[3]), this._setWidthHeight(e) }, _setWidthHeight: function (t) { t || (t = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in t ? t.left : this._getLeftToOriginX(), this.top = "top" in t ? t.top : this._getTopToOriginY() }, _set: function (t, e) { return this.callSuper("_set", t, e), "undefined" != typeof o[t] && this._setWidthHeight(), this }, _getLeftToOriginX: e({ origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" }, { nearest: "left", center: "center", farthest: "right" }), _getTopToOriginY: e({ origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" }, { nearest: "top", center: "center", farthest: "bottom" }), _render: function (t, e) { if (t.beginPath(), e) { var i = this.getCenterPoint(), r = this.strokeWidth / 2; t.translate(i.x - ("butt" === this.strokeLineCap && 0 === this.height ? 0 : r), i.y - ("butt" === this.strokeLineCap && 0 === this.width ? 0 : r)) } if (!this.strokeDashArray || this.strokeDashArray && s) { var n = this.calcLinePoints(); t.moveTo(n.x1, n.y1), t.lineTo(n.x2, n.y2) } t.lineWidth = this.strokeWidth; var o = t.strokeStyle; t.strokeStyle = this.stroke || t.fillStyle, this.stroke && this._renderStroke(t), t.strokeStyle = o }, _renderDashedStroke: function (t) { var e = this.calcLinePoints(); t.beginPath(), i.util.drawDashedLine(t, e.x1, e.y1, e.x2, e.y2, this.strokeDashArray), t.closePath() }, toObject: function (t) { return r(this.callSuper("toObject", t), this.calcLinePoints()) }, _getNonTransformedDimensions: function () { var t = this.callSuper("_getNonTransformedDimensions"); return "butt" === this.strokeLineCap && (0 === this.width && (t.y -= this.strokeWidth), 0 === this.height && (t.x -= this.strokeWidth)), t }, calcLinePoints: function () { var t = this.x1 <= this.x2 ? -1 : 1, e = this.y1 <= this.y2 ? -1 : 1, i = t * this.width * .5, r = e * this.height * .5, n = t * this.width * -.5, o = e * this.height * -.5; return { x1: i, x2: n, y1: r, y2: o } }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 }; return this.group && "path-group" === this.group.type || (i = this.calcLinePoints()), e.push("<line ", this.getSvgId(), 'x1="', i.x1, '" y1="', i.y1, '" x2="', i.x2, '" y2="', i.y2, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n'), t ? t(e.join("")) : e.join("") } }), i.Line.ATTRIBUTE_NAMES = i.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), i.Line.fromElement = function (t, e) { e = e || {}; var n = i.parseAttributes(t, i.Line.ATTRIBUTE_NAMES), o = [n.x1 || 0, n.y1 || 0, n.x2 || 0, n.y2 || 0]; return e.originX = "left", e.originY = "top", new i.Line(o, r(n, e)) }, i.Line.fromObject = function (t, e, r) { function o(t) { delete t.points, e && e(t) } var s = n(t, !0); s.points = [t.x1, t.y1, t.x2, t.y2]; var a = i.Object._fromObject("Line", s, o, r, "points"); return a && delete a.points, a } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; function e(t) { return "radius" in t && t.radius >= 0 } var i = t.fabric || (t.fabric = {}), r = Math.PI, n = i.util.object.extend; if (i.Circle) return void i.warn("fabric.Circle is already defined."); var s = i.Object.prototype.cacheProperties.concat(); s.push("radius"), i.Circle = i.util.createClass(i.Object, { type: "circle", radius: 0, startAngle: 0, endAngle: 2 * r, cacheProperties: s, initialize: function (t) { this.callSuper("initialize", t), this.set("radius", t && t.radius || 0) }, _set: function (t, e) { return this.callSuper("_set", t, e), "radius" === t && this.setRadius(e), this }, toObject: function (t) { return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(t)) }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = 0, n = 0, s = (this.endAngle - this.startAngle) % (2 * r); if (0 === s) this.group && "path-group" === this.group.type && (i = this.left + this.radius, n = this.top + this.radius), e.push("<circle ", this.getSvgId(), 'cx="' + i + '" cy="' + n + '" ', 'r="', this.radius, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), " ", this.getSvgTransformMatrix(), '"/>\n'); else { var o = Math.cos(this.startAngle) * this.radius, a = Math.sin(this.startAngle) * this.radius, c = Math.cos(this.endAngle) * this.radius, h = Math.sin(this.endAngle) * this.radius, u = s > r ? "1" : "0"; e.push('<path d="M ' + o + " " + a, " A " + this.radius + " " + this.radius, " 0 ", +u + " 1", " " + c + " " + h, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), " ", this.getSvgTransformMatrix(), '"/>\n') } return t ? t(e.join("")) : e.join("") }, _render: function (t, e) { t.beginPath(), t.arc(e ? this.left + this.radius : 0, e ? this.top + this.radius : 0, this.radius, this.startAngle, this.endAngle, !1), this._renderFill(t), this._renderStroke(t) }, getRadiusX: function () { return this.get("radius") * this.get("scaleX") }, getRadiusY: function () { return this.get("radius") * this.get("scaleY") }, setRadius: function (t) { return this.radius = t, this.set("width", 2 * t).set("height", 2 * t) } }), i.Circle.ATTRIBUTE_NAMES = i.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), i.Circle.fromElement = function (t, r) { r || (r = {}); var s = i.parseAttributes(t, i.Circle.ATTRIBUTE_NAMES); if (!e(s)) throw new Error("value of `r` attribute is required and can not be negative"); s.left = s.left || 0, s.top = s.top || 0; var o = new i.Circle(n(s, r)); return o.left -= o.radius, o.top -= o.radius, o }, i.Circle.fromObject = function (t, e, r) { return i.Object._fromObject("Circle", t, e, r) } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}); return e.Triangle ? void e.warn("fabric.Triangle is already defined") : (e.Triangle = e.util.createClass(e.Object, { type: "triangle", initialize: function (t) { this.callSuper("initialize", t), this.set("width", t && t.width || 100).set("height", t && t.height || 100) }, _render: function (t) { var e = this.width / 2, i = this.height / 2; t.beginPath(), t.moveTo(-e, i), t.lineTo(0, -i), t.lineTo(e, i), t.closePath(), this._renderFill(t), this._renderStroke(t) }, _renderDashedStroke: function (t) { var i = this.width / 2, r = this.height / 2; t.beginPath(), e.util.drawDashedLine(t, -i, r, 0, -r, this.strokeDashArray), e.util.drawDashedLine(t, 0, -r, i, r, this.strokeDashArray), e.util.drawDashedLine(t, i, r, -i, r, this.strokeDashArray), t.closePath() }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = this.width / 2, r = this.height / 2, n = [-i + " " + r, "0 " + -r, i + " " + r].join(","); return e.push("<polygon ", this.getSvgId(), 'points="', n, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), '"/>'), t ? t(e.join("")) : e.join("") } }), void (e.Triangle.fromObject = function (t, i, r) { return e.Object._fromObject("Triangle", t, i, r) })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = 2 * Math.PI, r = e.util.object.extend; if (e.Ellipse) return void e.warn("fabric.Ellipse is already defined."); var n = e.Object.prototype.cacheProperties.concat(); n.push("rx", "ry"), e.Ellipse = e.util.createClass(e.Object, { type: "ellipse", rx: 0, ry: 0, cacheProperties: n, initialize: function (t) { this.callSuper("initialize", t), this.set("rx", t && t.rx || 0), this.set("ry", t && t.ry || 0) }, _set: function (t, e) { switch (this.callSuper("_set", t, e), t) { case "rx": this.rx = e, this.set("width", 2 * e); break; case "ry": this.ry = e, this.set("height", 2 * e) } return this }, getRx: function () { return this.get("rx") * this.get("scaleX") }, getRy: function () { return this.get("ry") * this.get("scaleY") }, toObject: function (t) { return this.callSuper("toObject", ["rx", "ry"].concat(t)) }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = 0, r = 0; return this.group && "path-group" === this.group.type && (i = this.left + this.rx, r = this.top + this.ry), e.push("<ellipse ", this.getSvgId(), 'cx="', i, '" cy="', r, '" ', 'rx="', this.rx, '" ry="', this.ry, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n'), t ? t(e.join("")) : e.join("") }, _render: function (t, e) { t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(e ? this.left + this.rx : 0, e ? (this.top + this.ry) * this.rx / this.ry : 0, this.rx, 0, i, !1), t.restore(), this._renderFill(t), this._renderStroke(t) } }), e.Ellipse.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), e.Ellipse.fromElement = function (t, i) { i || (i = {}); var n = e.parseAttributes(t, e.Ellipse.ATTRIBUTE_NAMES); n.left = n.left || 0, n.top = n.top || 0; var s = new e.Ellipse(r(n, i)); return s.top -= s.ry, s.left -= s.rx, s }, e.Ellipse.fromObject = function (t, i, r) { return e.Object._fromObject("Ellipse", t, i, r) } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend; if (e.Rect) return void e.warn("fabric.Rect is already defined"); var r = e.Object.prototype.stateProperties.concat(); r.push("rx", "ry"); var n = e.Object.prototype.cacheProperties.concat(); n.push("rx", "ry"), e.Rect = e.util.createClass(e.Object, { stateProperties: r, type: "rect", rx: 0, ry: 0, cacheProperties: n, initialize: function (t) { this.callSuper("initialize", t), this._initRxRy() }, _initRxRy: function () { this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry) }, _render: function (t, e) { if (1 === this.width && 1 === this.height) return void t.fillRect(-.5, -.5, 1, 1); var i = this.rx ? Math.min(this.rx, this.width / 2) : 0, r = this.ry ? Math.min(this.ry, this.height / 2) : 0, n = this.width, s = this.height, o = e ? this.left : -this.width / 2, a = e ? this.top : -this.height / 2, c = 0 !== i || 0 !== r, h = .4477152502; t.beginPath(), t.moveTo(o + i, a), t.lineTo(o + n - i, a), c && t.bezierCurveTo(o + n - h * i, a, o + n, a + h * r, o + n, a + r), t.lineTo(o + n, a + s - r), c && t.bezierCurveTo(o + n, a + s - h * r, o + n - h * i, a + s, o + n - i, a + s), t.lineTo(o + i, a + s), c && t.bezierCurveTo(o + h * i, a + s, o, a + s - h * r, o, a + s - r), t.lineTo(o, a + r), c && t.bezierCurveTo(o, a + h * r, o + h * i, a, o + i, a), t.closePath(), this._renderFill(t), this._renderStroke(t) }, _renderDashedStroke: function (t) { var i = -this.width / 2, r = -this.height / 2, n = this.width, s = this.height; t.beginPath(), e.util.drawDashedLine(t, i, r, i + n, r, this.strokeDashArray), e.util.drawDashedLine(t, i + n, r, i + n, r + s, this.strokeDashArray), e.util.drawDashedLine(t, i + n, r + s, i, r + s, this.strokeDashArray), e.util.drawDashedLine(t, i, r + s, i, r, this.strokeDashArray), t.closePath() }, toObject: function (t) { return this.callSuper("toObject", ["rx", "ry"].concat(t)) }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = this.left, r = this.top; return this.group && "path-group" === this.group.type || (i = -this.width / 2, r = -this.height / 2), e.push("<rect ", this.getSvgId(), 'x="', i, '" y="', r, '" rx="', this.get("rx"), '" ry="', this.get("ry"), '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n'), t ? t(e.join("")) : e.join("") } }), e.Rect.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), e.Rect.fromElement = function (t, r) { if (!t) return null; r = r || {}; var n = e.parseAttributes(t, e.Rect.ATTRIBUTE_NAMES); n.left = n.left || 0, n.top = n.top || 0; var s = new e.Rect(i(r ? e.util.object.clone(r) : {}, n)); return s.visible = s.visible && s.width > 0 && s.height > 0, s }, e.Rect.fromObject = function (t, i, r) { return e.Object._fromObject("Rect", t, i, r) } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.util.array.min, n = e.util.array.max, s = e.util.toFixed; if (e.Polyline) return void e.warn("fabric.Polyline is already defined"); var o = e.Object.prototype.cacheProperties.concat(); o.push("points"), e.Polyline = e.util.createClass(e.Object, { type: "polyline", points: null, minX: 0, minY: 0, cacheProperties: o, initialize: function (t, e) { e = e || {}, this.points = t || [], this.callSuper("initialize", e), this._calcDimensions(), "top" in e || (this.top = this.minY), "left" in e || (this.left = this.minX), this.pathOffset = { x: this.minX + this.width / 2, y: this.minY + this.height / 2 } }, _calcDimensions: function () { var t = this.points, e = r(t, "x"), i = r(t, "y"), s = n(t, "x"), o = n(t, "y"); this.width = s - e || 0, this.height = o - i || 0, this.minX = e || 0, this.minY = i || 0 }, toObject: function (t) { return i(this.callSuper("toObject", t), { points: this.points.concat() }) }, toSVG: function (t) { for (var e, i = [], r = this._createBaseSVGMarkup(), n = 0, o = this.points.length; o > n; n++) i.push(s(this.points[n].x, 2), ",", s(this.points[n].y, 2), " "); return this.group && "path-group" === this.group.type || (e = " translate(" + -this.pathOffset.x + ", " + -this.pathOffset.y + ") "), r.push("<", this.type, " ", this.getSvgId(), 'points="', i.join(""), '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), e, " ", this.getSvgTransformMatrix(), '"/>\n'), t ? t(r.join("")) : r.join("") }, commonRender: function (t, e) { var i, r = this.points.length, n = e ? 0 : this.pathOffset.x, s = e ? 0 : this.pathOffset.y; if (!r || isNaN(this.points[r - 1].y)) return !1; t.beginPath(), t.moveTo(this.points[0].x - n, this.points[0].y - s); for (var o = 0; r > o; o++) i = this.points[o], t.lineTo(i.x - n, i.y - s); return !0 }, _render: function (t, e) { this.commonRender(t, e) && (this._renderFill(t), this._renderStroke(t)) }, _renderDashedStroke: function (t) { var i, r; t.beginPath(); for (var n = 0, s = this.points.length; s > n; n++) i = this.points[n], r = this.points[n + 1] || i, e.util.drawDashedLine(t, i.x, i.y, r.x, r.y, this.strokeDashArray) }, complexity: function () { return this.get("points").length } }), e.Polyline.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polyline.fromElement = function (t, i) { if (!t) return null; i || (i = {}); var r = e.parsePointsAttribute(t.getAttribute("points")), n = e.parseAttributes(t, e.Polyline.ATTRIBUTE_NAMES); return new e.Polyline(r, e.util.object.extend(n, i)) }, e.Polyline.fromObject = function (t, i, r) { return e.Object._fromObject("Polyline", t, i, r, "points") } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend; return e.Polygon ? void e.warn("fabric.Polygon is already defined") : (e.Polygon = e.util.createClass(e.Polyline, { type: "polygon", _render: function (t, e) { this.commonRender(t, e) && (t.closePath(), this._renderFill(t), this._renderStroke(t)) }, _renderDashedStroke: function (t) { this.callSuper("_renderDashedStroke", t), t.closePath() } }), e.Polygon.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polygon.fromElement = function (t, r) { if (!t) return null; r || (r = {}); var n = e.parsePointsAttribute(t.getAttribute("points")), s = e.parseAttributes(t, e.Polygon.ATTRIBUTE_NAMES); return new e.Polygon(n, i(s, r)) }, void (e.Polygon.fromObject = function (t, i, r) { return e.Object._fromObject("Polygon", t, i, r, "points") })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.array.min, r = e.util.array.max, n = e.util.object.extend, s = Object.prototype.toString, o = e.util.drawArc, a = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, c = { m: "l", M: "L" }; if (e.Path) return void e.warn("fabric.Path is already defined"); var h = e.Object.prototype.cacheProperties.concat(); h.push("path"), e.Path = e.util.createClass(e.Object, { type: "path", path: null, minX: 0, minY: 0, cacheProperties: h, initialize: function (t, e) { e = e || {}, e && this.setOptions(e), t || (t = []); var i = "[object Array]" === s.call(t); this.path = i ? t : t.match && t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi), this.path && (i || (this.path = this._parsePath()), this._setPositionDimensions(e), e.sourcePath && this.setSourcePath(e.sourcePath), this.objectCaching && (this._createCacheCanvas(), this.setupState({ propertySet: "cacheProperties" }))) }, _setPositionDimensions: function (t) { var e = this._parseDimensions(); this.minX = e.left, this.minY = e.top, this.width = e.width, this.height = e.height, "undefined" == typeof t.left && (this.left = e.left + ("center" === this.originX ? this.width / 2 : "right" === this.originX ? this.width : 0)), "undefined" == typeof t.top && (this.top = e.top + ("center" === this.originY ? this.height / 2 : "bottom" === this.originY ? this.height : 0)), this.pathOffset = this.pathOffset || { x: this.minX + this.width / 2, y: this.minY + this.height / 2 } }, _renderPathCommands: function (t) { var e, i, r, n = null, s = 0, a = 0, c = 0, h = 0, u = 0, l = 0, f = -this.pathOffset.x, d = -this.pathOffset.y; this.group && "path-group" === this.group.type && (f = 0, d = 0), t.beginPath(); for (var p = 0, g = this.path.length; g > p; ++p) { switch (e = this.path[p], e[0]) { case "l": c += e[1], h += e[2], t.lineTo(c + f, h + d); break; case "L": c = e[1], h = e[2], t.lineTo(c + f, h + d); break; case "h": c += e[1], t.lineTo(c + f, h + d); break; case "H": c = e[1], t.lineTo(c + f, h + d); break; case "v": h += e[1], t.lineTo(c + f, h + d); break; case "V": h = e[1], t.lineTo(c + f, h + d); break; case "m": c += e[1], h += e[2], s = c, a = h, t.moveTo(c + f, h + d); break; case "M": c = e[1], h = e[2], s = c, a = h, t.moveTo(c + f, h + d); break; case "c": i = c + e[5], r = h + e[6], u = c + e[3], l = h + e[4], t.bezierCurveTo(c + e[1] + f, h + e[2] + d, u + f, l + d, i + f, r + d), c = i, h = r; break; case "C": c = e[5], h = e[6], u = e[3], l = e[4], t.bezierCurveTo(e[1] + f, e[2] + d, u + f, l + d, c + f, h + d); break; case "s": i = c + e[3], r = h + e[4], null === n[0].match(/[CcSs]/) ? (u = c, l = h) : (u = 2 * c - u, l = 2 * h - l), t.bezierCurveTo(u + f, l + d, c + e[1] + f, h + e[2] + d, i + f, r + d), u = c + e[1], l = h + e[2], c = i, h = r; break; case "S": i = e[3], r = e[4], null === n[0].match(/[CcSs]/) ? (u = c, l = h) : (u = 2 * c - u, l = 2 * h - l), t.bezierCurveTo(u + f, l + d, e[1] + f, e[2] + d, i + f, r + d), c = i, h = r, u = e[1], l = e[2]; break; case "q": i = c + e[3], r = h + e[4], u = c + e[1], l = h + e[2], t.quadraticCurveTo(u + f, l + d, i + f, r + d), c = i, h = r; break; case "Q": i = e[3], r = e[4], t.quadraticCurveTo(e[1] + f, e[2] + d, i + f, r + d), c = i, h = r, u = e[1], l = e[2]; break; case "t": i = c + e[1], r = h + e[2], null === n[0].match(/[QqTt]/) ? (u = c, l = h) : (u = 2 * c - u, l = 2 * h - l), t.quadraticCurveTo(u + f, l + d, i + f, r + d), c = i, h = r; break; case "T": i = e[1], r = e[2], null === n[0].match(/[QqTt]/) ? (u = c, l = h) : (u = 2 * c - u, l = 2 * h - l), t.quadraticCurveTo(u + f, l + d, i + f, r + d), c = i, h = r; break; case "a": o(t, c + f, h + d, [e[1], e[2], e[3], e[4], e[5], e[6] + c + f, e[7] + h + d]), c += e[6], h += e[7]; break; case "A": o(t, c + f, h + d, [e[1], e[2], e[3], e[4], e[5], e[6] + f, e[7] + d]), c = e[6], h = e[7]; break; case "z": case "Z": c = s, h = a, t.closePath() } n = e } }, _render: function (t) { this._renderPathCommands(t), this._renderFill(t), this._renderStroke(t) }, toString: function () { return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>" }, toObject: function (t) { var e = n(this.callSuper("toObject", ["sourcePath", "pathOffset"].concat(t)), { path: this.path.map(function (t) { return t.slice() }), top: this.top, left: this.left }); return e }, toDatalessObject: function (t) { var e = this.toObject(t); return this.sourcePath && (e.path = this.sourcePath), delete e.sourcePath, e }, toSVG: function (t) { for (var e = [], i = this._createBaseSVGMarkup(), r = "", n = 0, s = this.path.length; s > n; n++) e.push(this.path[n].join(" ")); var o = e.join(" "); return this.group && "path-group" === this.group.type || (r = " translate(" + -this.pathOffset.x + ", " + -this.pathOffset.y + ") "), i.push("<path ", this.getSvgId(), 'd="', o, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), r, this.getSvgTransformMatrix(), '" stroke-linecap="round" ', "/>\n"), t ? t(i.join("")) : i.join("") }, complexity: function () { return this.path.length }, _parsePath: function () { for (var t, e, i, r, n, s = [], o = [], h = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi, u = 0, l = this.path.length; l > u; u++) { for (t = this.path[u], r = t.slice(1).trim(), o.length = 0; i = h.exec(r) ;) o.push(i[0]); n = [t.charAt(0)]; for (var f = 0, d = o.length; d > f; f++) e = parseFloat(o[f]), isNaN(e) || n.push(e); var p = n[0], g = a[p.toLowerCase()], v = c[p] || p; if (n.length - 1 > g) for (var m = 1, y = n.length; y > m; m += g) s.push([p].concat(n.slice(m, m + g))), p = v; else s.push(n) } return s }, _parseDimensions: function () { for (var t, n, s, o, a = [], c = [], h = null, u = 0, l = 0, f = 0, d = 0, p = 0, g = 0, v = 0, m = this.path.length; m > v; ++v) { switch (t = this.path[v], t[0]) { case "l": f += t[1], d += t[2], o = []; break; case "L": f = t[1], d = t[2], o = []; break; case "h": f += t[1], o = []; break; case "H": f = t[1], o = []; break; case "v": d += t[1], o = []; break; case "V": d = t[1], o = []; break; case "m": f += t[1], d += t[2], u = f, l = d, o = []; break; case "M": f = t[1], d = t[2], u = f, l = d, o = []; break; case "c": n = f + t[5], s = d + t[6], p = f + t[3], g = d + t[4], o = e.util.getBoundsOfCurve(f, d, f + t[1], d + t[2], p, g, n, s), f = n, d = s; break; case "C": p = t[3], g = t[4], o = e.util.getBoundsOfCurve(f, d, t[1], t[2], p, g, t[5], t[6]), f = t[5], d = t[6]; break; case "s": n = f + t[3], s = d + t[4], null === h[0].match(/[CcSs]/) ? (p = f, g = d) : (p = 2 * f - p, g = 2 * d - g), o = e.util.getBoundsOfCurve(f, d, p, g, f + t[1], d + t[2], n, s), p = f + t[1], g = d + t[2], f = n, d = s; break; case "S": n = t[3], s = t[4], null === h[0].match(/[CcSs]/) ? (p = f, g = d) : (p = 2 * f - p, g = 2 * d - g), o = e.util.getBoundsOfCurve(f, d, p, g, t[1], t[2], n, s), f = n, d = s, p = t[1], g = t[2]; break; case "q": n = f + t[3], s = d + t[4], p = f + t[1], g = d + t[2], o = e.util.getBoundsOfCurve(f, d, p, g, p, g, n, s), f = n, d = s; break; case "Q": p = t[1], g = t[2], o = e.util.getBoundsOfCurve(f, d, p, g, p, g, t[3], t[4]), f = t[3], d = t[4]; break; case "t": n = f + t[1], s = d + t[2], null === h[0].match(/[QqTt]/) ? (p = f, g = d) : (p = 2 * f - p, g = 2 * d - g), o = e.util.getBoundsOfCurve(f, d, p, g, p, g, n, s), f = n, d = s; break; case "T": n = t[1], s = t[2], null === h[0].match(/[QqTt]/) ? (p = f, g = d) : (p = 2 * f - p, g = 2 * d - g), o = e.util.getBoundsOfCurve(f, d, p, g, p, g, n, s), f = n, d = s; break; case "a": o = e.util.getBoundsOfArc(f, d, t[1], t[2], t[3], t[4], t[5], t[6] + f, t[7] + d), f += t[6], d += t[7]; break; case "A": o = e.util.getBoundsOfArc(f, d, t[1], t[2], t[3], t[4], t[5], t[6], t[7]), f = t[6], d = t[7]; break; case "z": case "Z": f = u, d = l } h = t, o.forEach(function (t) { a.push(t.x), c.push(t.y) }), a.push(f), c.push(d) } var y = i(a) || 0, b = i(c) || 0, _ = r(a) || 0, w = r(c) || 0, x = _ - y, C = w - b, j = { left: y, top: b, width: x, height: C }; return j } }), e.Path.fromObject = function (t, i, r) { var n; return "string" != typeof t.path ? e.Object._fromObject("Path", t, i, r, "path") : void e.loadSVGFromURL(t.path, function (r) { var s = t.path; n = r[0], delete t.path, e.util.object.extend(n, t), n.setSourcePath(s), i && i(n) }) }, e.Path.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(["d"]), e.Path.fromElement = function (t, i, r) { var s = e.parseAttributes(t, e.Path.ATTRIBUTE_NAMES); i && i(new e.Path(s.d, n(s, r))) }, e.Path.async = !0 }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend; return e.PathGroup ? void e.warn("fabric.PathGroup is already defined") : (e.PathGroup = e.util.createClass(e.Object, { type: "path-group", fill: "", initialize: function (t, e) { e = e || {}, this.paths = t || []; for (var i = this.paths.length; i--;) this.paths[i].group = this; e.toBeParsed && (this.parseDimensionsFromPaths(e), delete e.toBeParsed), this.setOptions(e), this.setCoords(), e.sourcePath && this.setSourcePath(e.sourcePath), this.objectCaching && (this._createCacheCanvas(), this.setupState({ propertySet: "cacheProperties" })) }, parseDimensionsFromPaths: function (t) { for (var i, r, n, s, o, a, c = [], h = [], l = this.paths.length; l--;) { n = this.paths[l], s = n.height + n.strokeWidth, o = n.width + n.strokeWidth, i = [{ x: n.left, y: n.top }, { x: n.left + o, y: n.top }, { x: n.left, y: n.top + s }, { x: n.left + o, y: n.top + s }], a = this.paths[l].transformMatrix; for (var u = 0; u < i.length; u++) r = i[u], a && (r = e.util.transformPoint(r, a, !1)), c.push(r.x), h.push(r.y) } t.width = Math.max.apply(null, c), t.height = Math.max.apply(null, h) }, drawObject: function (t) { t.save(), t.translate(-this.width / 2, -this.height / 2); for (var e = 0, i = this.paths.length; i > e; ++e) this.paths[e].render(t, !0); t.restore() }, isCacheDirty: function () { if (this.callSuper("isCacheDirty")) return !0; if (!this.statefullCache) return !1; for (var t = 0, e = this.paths.length; e > t; t++) if (this.paths[t].isCacheDirty(!0)) { var i = this._getNonTransformedDimensions(); return this._cacheContext.clearRect(-i.x / 2, -i.y / 2, i.x, i.y), !0 } return !1 }, _set: function (t, e) { if ("fill" === t && e && this.isSameColor()) for (var i = this.paths.length; i--;) this.paths[i]._set(t, e); return this.callSuper("_set", t, e) }, toObject: function (t) { var e = this.paths.map(function (e) { var i = e.includeDefaultValues; e.includeDefaultValues = e.group.includeDefaultValues; var r = e.toObject(t); return e.includeDefaultValues = i, r }), r = i(this.callSuper("toObject", ["sourcePath"].concat(t)), { paths: e }); return r }, toDatalessObject: function (t) { var e = this.toObject(t); return this.sourcePath && (e.paths = this.sourcePath), e }, toSVG: function (t) { var e = this.getObjects(), i = this.getPointByOrigin("left", "top"), r = "translate(" + i.x + " " + i.y + ")", n = this._createBaseSVGMarkup(); n.push("<g ", this.getSvgId(), 'style="', this.getSvgStyles(), '" ', 'transform="', this.getSvgTransformMatrix(), r, this.getSvgTransform(), '" ', ">\n"); for (var s = 0, o = e.length; o > s; s++) n.push("	", e[s].toSVG(t)); return n.push("</g>\n"), t ? t(n.join("")) : n.join("") }, toString: function () { return "#<fabric.PathGroup (" + this.complexity() + "): { top: " + this.top + ", left: " + this.left + " }>" }, isSameColor: function () { var t = this.getObjects()[0].get("fill") || ""; return "string" != typeof t ? !1 : (t = t.toLowerCase(), this.getObjects().every(function (e) { var i = e.get("fill") || ""; return "string" == typeof i && i.toLowerCase() === t })) }, complexity: function () { return this.paths.reduce(function (t, e) { return t + (e && e.complexity ? e.complexity() : 0) }, 0) }, getObjects: function () { return this.paths } }), e.PathGroup.fromObject = function (t, i) { var r = t.paths; delete t.paths, "string" == typeof r ? e.loadSVGFromURL(r, function (n) { var s = r, o = e.util.groupSVGElements(n, t, s); t.paths = r, i(o) }) : e.util.enlivenObjects(r, function (n) { var s = new e.PathGroup(n, t); t.paths = r, i(s) }) }, void (e.PathGroup.async = !0)) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.util.array.min, n = e.util.array.max; if (!e.Group) { var s = { lockMovementX: !0, lockMovementY: !0, lockRotation: !0, lockScalingX: !0, lockScalingY: !0, lockUniScaling: !0 }; e.Group = e.util.createClass(e.Object, e.Collection, { type: "group", strokeWidth: 0, subTargetCheck: !1, initialize: function (t, e, i) { e = e || {}, this._objects = [], i && this.callSuper("initialize", e), this._objects = t || []; for (var r = this._objects.length; r--;) this._objects[r].group = this; this.originalState = {}, e.originX && (this.originX = e.originX), e.originY && (this.originY = e.originY), i ? this._updateObjectsCoords(!0) : (this._calcBounds(), this._updateObjectsCoords(), this.callSuper("initialize", e)), this.setCoords(), this.saveCoords() }, _updateObjectsCoords: function (t) { for (var e = this.getCenterPoint(), i = this._objects.length; i--;) this._updateObjectCoords(this._objects[i], e, t) }, _updateObjectCoords: function (t, e, i) { if (t.__origHasControls = t.hasControls, t.hasControls = !1, !i) { var r = t.getLeft(), n = t.getTop(), s = !0, o = !0; t.set({ left: r - e.x, top: n - e.y }), t.setCoords(s, o) } }, toString: function () { return "#<fabric.Group: (" + this.complexity() + ")>" }, addWithUpdate: function (t) { return this._restoreObjectsState(), e.util.resetObjectTransform(this), t && (this._objects.push(t), t.group = this, t._set("canvas", this.canvas)), this.forEachObject(this._setObjectActive, this), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, this }, _setObjectActive: function (t) { t.set("active", !0), t.group = this }, removeWithUpdate: function (t) { return this._restoreObjectsState(), e.util.resetObjectTransform(this), this.forEachObject(this._setObjectActive, this), this.remove(t), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, this }, _onObjectAdded: function (t) { this.dirty = !0, t.group = this, t._set("canvas", this.canvas) }, _onObjectRemoved: function (t) { this.dirty = !0, delete t.group, t.set("active", !1) }, delegatedProperties: { fill: !0, stroke: !0, strokeWidth: !0, fontFamily: !0, fontWeight: !0, fontSize: !0, fontStyle: !0, lineHeight: !0, textDecoration: !0, textAlign: !0, backgroundColor: !0 }, _set: function (t, e) { var i = this._objects.length; if (this.delegatedProperties[t] || "canvas" === t) for (; i--;) this._objects[i].set(t, e); else for (; i--;) this._objects[i].setOnGroup(t, e); this.callSuper("_set", t, e) }, toObject: function (t) { var e = this.getObjects().map(function (e) { var i = e.includeDefaultValues; e.includeDefaultValues = e.group.includeDefaultValues; var r = e.toObject(t); return e.includeDefaultValues = i, r }); return i(this.callSuper("toObject", t), { objects: e }) }, render: function (t) { this._transformDone = !0, this.callSuper("render", t), this._transformDone = !1 }, drawObject: function (t) { for (var e = 0, i = this._objects.length; i > e; e++) this._renderObject(this._objects[e], t) }, isCacheDirty: function () { if (this.callSuper("isCacheDirty")) return !0; if (!this.statefullCache) return !1; for (var t = 0, e = this._objects.length; e > t; t++) if (this._objects[t].isCacheDirty(!0)) { var i = this._getNonTransformedDimensions(); return this._cacheContext.clearRect(-i.x / 2, -i.y / 2, i.x, i.y), !0 } return !1 }, _renderControls: function (t, e) { t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", t, e); for (var i = 0, r = this._objects.length; r > i; i++) this._objects[i]._renderControls(t); t.restore() }, _renderObject: function (t, e) { if (t.visible) { var i = t.hasRotatingPoint; t.hasRotatingPoint = !1, t.render(e), t.hasRotatingPoint = i } }, _restoreObjectsState: function () { return this._objects.forEach(this._restoreObjectState, this), this }, realizeTransform: function (t) { var i = t.calcTransformMatrix(), r = e.util.qrDecompose(i), n = new e.Point(r.translateX, r.translateY); return t.flipX = !1, t.flipY = !1, t.set("scaleX", r.scaleX), t.set("scaleY", r.scaleY), t.skewX = r.skewX, t.skewY = r.skewY, t.angle = r.angle, t.setPositionByOrigin(n, "center", "center"), t }, _restoreObjectState: function (t) { return this.realizeTransform(t), t.setCoords(), t.hasControls = t.__origHasControls, delete t.__origHasControls, t.set("active", !1), delete t.group, this }, destroy: function () { return this._restoreObjectsState() }, saveCoords: function () { return this._originalLeft = this.get("left"), this._originalTop = this.get("top"), this }, hasMoved: function () { return this._originalLeft !== this.get("left") || this._originalTop !== this.get("top") }, setObjectsCoords: function () { var t = !0, e = !0; return this.forEachObject(function (i) { i.setCoords(t, e) }), this }, _calcBounds: function (t) { for (var e, i, r, n = [], s = [], o = ["tr", "br", "bl", "tl"], a = 0, c = this._objects.length, h = o.length, l = !0; c > a; ++a) for (e = this._objects[a], e.setCoords(l), r = 0; h > r; r++) i = o[r], n.push(e.oCoords[i].x), s.push(e.oCoords[i].y); this.set(this._getBounds(n, s, t)) }, _getBounds: function (t, i, s) { var o = new e.Point(r(t), r(i)), a = new e.Point(n(t), n(i)), c = { width: a.x - o.x || 0, height: a.y - o.y || 0 }; return s || (c.left = o.x || 0, c.top = o.y || 0, "center" === this.originX && (c.left += c.width / 2), "right" === this.originX && (c.left += c.width), "center" === this.originY && (c.top += c.height / 2), "bottom" === this.originY && (c.top += c.height)), c }, toSVG: function (t) { var e = this._createBaseSVGMarkup(); e.push("<g ", this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '" style="', this.getSvgFilter(), '">\n'); for (var i = 0, r = this._objects.length; r > i; i++) e.push("	", this._objects[i].toSVG(t)); return e.push("</g>\n"), t ? t(e.join("")) : e.join("") }, get: function (t) { if (t in s) { if (this[t]) return this[t]; for (var e = 0, i = this._objects.length; i > e; e++) if (this._objects[e][t]) return !0; return !1 } return t in this.delegatedProperties ? this._objects[0] && this._objects[0].get(t) : this[t] } }), e.Group.fromObject = function (t, i) { e.util.enlivenObjects(t.objects, function (r) { delete t.objects, i && i(new e.Group(r, t, !0)) }) }, e.Group.async = !0 } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = fabric.util.object.extend; if (t.fabric || (t.fabric = {}), t.fabric.Image) return void fabric.warn("fabric.Image is already defined."); var i = fabric.Object.prototype.stateProperties.concat(); i.push("alignX", "alignY", "meetOrSlice"), fabric.Image = fabric.util.createClass(fabric.Object, { type: "image", crossOrigin: "", alignX: "none", alignY: "none", meetOrSlice: "meet", strokeWidth: 0, _lastScaleX: 1, _lastScaleY: 1, minimumScaleTrigger: .5, stateProperties: i, objectCaching: !1, initialize: function (t, e, i) { e || (e = {}), this.filters = [], this.resizeFilters = [], this.callSuper("initialize", e), this._initElement(t, e, i) }, getElement: function () { return this._element }, setElement: function (t, e, i) { var r, n; return this._element = t, this._originalElement = t, this._initConfig(i), 0 === this.resizeFilters.length ? r = e : (n = this, r = function () { n.applyFilters(e, n.resizeFilters, n._filteredEl || n._originalElement, !0) }), 0 !== this.filters.length ? this.applyFilters(r) : r && r(this), this }, setCrossOrigin: function (t) { return this.crossOrigin = t, this._element.crossOrigin = t, this }, getOriginalSize: function () { var t = this.getElement(); return { width: t.width, height: t.height } }, _stroke: function (t) { if (this.stroke && 0 !== this.strokeWidth) { var e = this.width / 2, i = this.height / 2; t.beginPath(), t.moveTo(-e, -i), t.lineTo(e, -i), t.lineTo(e, i), t.lineTo(-e, i), t.lineTo(-e, -i), t.closePath() } }, _renderDashedStroke: function (t) { var e = -this.width / 2, i = -this.height / 2, r = this.width, n = this.height; t.save(), this._setStrokeStyles(t), t.beginPath(), fabric.util.drawDashedLine(t, e, i, e + r, i, this.strokeDashArray), fabric.util.drawDashedLine(t, e + r, i, e + r, i + n, this.strokeDashArray), fabric.util.drawDashedLine(t, e + r, i + n, e, i + n, this.strokeDashArray), fabric.util.drawDashedLine(t, e, i + n, e, i, this.strokeDashArray), t.closePath(), t.restore() }, toObject: function (t) { var i = [], r = [], n = 1, s = 1; this.filters.forEach(function (t) { t && ("Resize" === t.type && (n *= t.scaleX, s *= t.scaleY), i.push(t.toObject())) }), this.resizeFilters.forEach(function (t) { t && r.push(t.toObject()) }); var o = e(this.callSuper("toObject", ["crossOrigin", "alignX", "alignY", "meetOrSlice"].concat(t)), { src: this.getSrc(), filters: i, resizeFilters: r }); return o.width /= n, o.height /= s, o }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = -this.width / 2, r = -this.height / 2, n = "none", s = !0; if (this.group && "path-group" === this.group.type && (i = this.left, r = this.top), "none" !== this.alignX && "none" !== this.alignY && (n = "x" + this.alignX + "Y" + this.alignY + " " + this.meetOrSlice), e.push('<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n', "<image ", this.getSvgId(), 'xlink:href="', this.getSvgSrc(s), '" x="', i, '" y="', r, '" style="', this.getSvgStyles(), '" width="', this.width, '" height="', this.height, '" preserveAspectRatio="', n, '"', "></image>\n"), this.stroke || this.strokeDashArray) { var o = this.fill; this.fill = null, e.push("<rect ", 'x="', i, '" y="', r, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '"/>\n'), this.fill = o } return e.push("</g>\n"), t ? t(e.join("")) : e.join("") }, getSrc: function (t) { var e = t ? this._element : this._originalElement; return e ? fabric.isLikelyNode ? e._src : e.src : this.src || "" }, setSrc: function (t, e, i) { fabric.util.loadImage(t, function (t) { return this.setElement(t, e, i) }, this, i && i.crossOrigin) }, toString: function () { return '#<fabric.Image: { src: "' + this.getSrc() + '" }>' }, applyFilters: function (t, e, i, r) { if (e = e || this.filters, i = i || this._originalElement) { var n, s, o = fabric.util.createImage(), a = this.canvas ? this.canvas.getRetinaScaling() : fabric.devicePixelRatio, c = this.minimumScaleTrigger / a, h = this; if (0 === e.length) return this._element = i, t && t(this), i; var l = fabric.util.createCanvasElement(); return l.width = i.width, l.height = i.height, l.getContext("2d").drawImage(i, 0, 0, i.width, i.height), e.forEach(function (t) { t && (r ? (n = h.scaleX < c ? h.scaleX : 1, s = h.scaleY < c ? h.scaleY : 1, 1 > n * a && (n *= a), 1 > s * a && (s *= a)) : (n = t.scaleX, s = t.scaleY), t.applyTo(l, n, s), r || "Resize" !== t.type || (h.width *= t.scaleX, h.height *= t.scaleY)) }), o.width = l.width, o.height = l.height, fabric.isLikelyNode ? (o.src = l.toBuffer(void 0, fabric.Image.pngCompression), h._element = o, !r && (h._filteredEl = o), t && t(h)) : (o.onload = function () { h._element = o, !r && (h._filteredEl = o), t && t(h), o.onload = l = null }, o.src = l.toDataURL("image/png")), l } }, _render: function (t, e) { var i, r, n, s = this._findMargins(); i = e ? this.left : -this.width / 2, r = e ? this.top : -this.height / 2, "slice" === this.meetOrSlice && (t.beginPath(), t.rect(i, r, this.width, this.height), t.clip()), this.isMoving === !1 && this.resizeFilters.length && this._needsResize() ? (this._lastScaleX = this.scaleX, this._lastScaleY = this.scaleY, n = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, !0)) : n = this._element, n && t.drawImage(n, i + s.marginX, r + s.marginY, s.width, s.height), this._stroke(t), this._renderStroke(t) }, _needsResize: function () { return this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY }, _findMargins: function () { var t, e, i = this.width, r = this.height, n = 0, s = 0; return ("none" !== this.alignX || "none" !== this.alignY) && (t = [this.width / this._element.width, this.height / this._element.height], e = "meet" === this.meetOrSlice ? Math.min.apply(null, t) : Math.max.apply(null, t), i = this._element.width * e, r = this._element.height * e, "Mid" === this.alignX && (n = (this.width - i) / 2), "Max" === this.alignX && (n = this.width - i), "Mid" === this.alignY && (s = (this.height - r) / 2), "Max" === this.alignY && (s = this.height - r)), { width: i, height: r, marginX: n, marginY: s } }, _resetWidthHeight: function () { var t = this.getElement(); this.set("width", t.width), this.set("height", t.height) }, _initElement: function (t, e, i) { this.setElement(fabric.util.getById(t), i, e), fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS) }, _initConfig: function (t) { t || (t = {}), this.setOptions(t), this._setWidthHeight(t), this._element && this.crossOrigin && (this._element.crossOrigin = this.crossOrigin) }, _initFilters: function (t, e) { t && t.length ? fabric.util.enlivenObjects(t, function (t) { e && e(t) }, "fabric.Image.filters") : e && e() }, _setWidthHeight: function (t) { this.width = "width" in t ? t.width : this.getElement() ? this.getElement().width || 0 : 0, this.height = "height" in t ? t.height : this.getElement() ? this.getElement().height || 0 : 0 } }), fabric.Image.CSS_CANVAS = "canvas-img", fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc, fabric.Image.fromObject = function (t, e) { fabric.util.loadImage(t.src, function (i, r) { return r ? void (e && e(null, r)) : void fabric.Image.prototype._initFilters.call(t, t.filters, function (r) { t.filters = r || [], fabric.Image.prototype._initFilters.call(t, t.resizeFilters, function (r) { return t.resizeFilters = r || [], new fabric.Image(i, t, e) }) }) }, null, t.crossOrigin) }, fabric.Image.fromURL = function (t, e, i) { fabric.util.loadImage(t, function (t) { e && e(new fabric.Image(t, i)) }, null, i && i.crossOrigin) }, fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin".split(" ")), fabric.Image.fromElement = function (t, i, r) { var n, s = fabric.parseAttributes(t, fabric.Image.ATTRIBUTE_NAMES); s.preserveAspectRatio && (n = fabric.util.parsePreserveAspectRatioAttribute(s.preserveAspectRatio), e(s, n)), fabric.Image.fromURL(s["xlink:href"], i, e(r ? fabric.util.object.clone(r) : {}, s)) }, fabric.Image.async = !0, fabric.Image.pngCompression = 1 }("undefined" != typeof exports ? exports : this);